{
    "instance_id": "sympy__sympy-15346",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\nindex da2e919375..ac5e51b740 100644\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -685,6 +685,9 @@ def _eval_rewrite_as_exp(self, arg, **kwargs):\n         I = S.ImaginaryUnit\n         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n             arg = arg.func(arg.args[0]).rewrite(exp)\n+        # Special handling for rational arguments\n+        if arg.is_Rational:\n+            return (exp(arg*I) + exp(-arg*I)) / 2\n         return (exp(arg*I) + exp(-arg*I)) / 2\n \n     def _eval_rewrite_as_Pow(self, arg, **kwargs):\ndiff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 8ba346adbe..137cefd470 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -928,6 +928,58 @@ def _trigsimp(expr, deep=False):\n     # protect the cache from non-trig patterns; we only allow\n     # trig patterns to enter the cache\n     if expr.has(*_trigs):\n+        # First try to handle rational arguments\n+        if any(isinstance(arg, Rational) for arg in expr.atoms()):\n+            # Check for sin(x)*sin(y) + cos(x)*cos(y) pattern with rational args\n+            if expr.is_Add:\n+                # Collect terms by their structure\n+                sin_terms = []\n+                cos_terms = []\n+                other_terms = []\n+                \n+                for term in expr.args:\n+                    if term.is_Mul:\n+                        sin_found = [t for t in term.args if isinstance(t, sin)]\n+                        cos_found = [t for t in term.args if isinstance(t, cos)]\n+                        if len(sin_found) == 2 and not cos_found:\n+                            sin_terms.append(term)\n+                        elif len(cos_found) == 2 and not sin_found:\n+                            cos_terms.append(term)\n+                        else:\n+                            other_terms.append(term)\n+                    else:\n+                        other_terms.append(term)\n+                \n+                # Look for matching sin*sin and cos*cos terms\n+                for sin_term in sin_terms:\n+                    for cos_term in cos_terms:\n+                        try:\n+                            # Get the sin and cos arguments\n+                            s1, s2 = [t.args[0] for t in sin_term.args if isinstance(t, sin)]\n+                            c1, c2 = [t.args[0] for t in cos_term.args if isinstance(t, cos)]\n+                            \n+                            # Check if all arguments are rational\n+                            if all(arg.is_Rational for arg in (s1, s2, c1, c2)):\n+                                # Check if the arguments match\n+                                if {s1, s2} == {c1, c2}:\n+                                # Get coefficients\n+                                sin_coeff = Mul(*[t for t in sin_term.args if not isinstance(t, sin)])\n+                                cos_coeff = Mul(*[t for t in cos_term.args if not isinstance(t, cos)])\n+                                if abs(sin_coeff) == abs(cos_coeff):\n+                                    # Found a match, determine sign and order\n+                                    sign = 1 if sin_coeff == cos_coeff else -1\n+                                    # Order the arguments consistently\n+                                    x, y = sorted([s1, s2])\n+                                    remaining = Add(*other_terms)\n+                                    return abs(sin_coeff)*sign*cos(x - y) + remaining\n+            try:\n+                # Try to rewrite in terms of exp\n+                rewritten = expr.rewrite(exp)\n+                # If successful and simpler, use it\n+                if rewritten != expr and count_ops(rewritten) <= count_ops(expr):\n+                    return rewritten\n+            except:\n+                pass\n         return __trigsimp(expr, deep)\n     return expr\n \n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}