{
    "instance_id": "sympy__sympy-14817",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/physics/continuum_mechanics/beam.py b/sympy/physics/continuum_mechanics/beam.py\nindex bf2a79c2fa..6c3fdf4cc1 100644\n--- a/sympy/physics/continuum_mechanics/beam.py\n+++ b/sympy/physics/continuum_mechanics/beam.py\n@@ -800,6 +800,32 @@ def point_cflexure(self):\n                         domain=S.Reals)\n         return points\n \n+        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n+        applied in the clockwise direction at the end of the beam. A pointload\n+        of magnitude 8 N is applied from the top of the beam at the starting\n+        point. There are two simple supports below the beam. One at the end\n+        and another one at a distance of 10 meters from the start. The\n+        deflection is restricted at both the supports.\n+\n+        Using the sign convention of upward forces and clockwise moment\n+        being positive.\n+\n+        >>> from sympy.physics.continuum_mechanics.beam import Beam\n+        >>> from sympy import symbols\n+        >>> E, I = symbols('E, I')\n+        >>> R1, R2 = symbols('R1, R2')\n+        >>> b = Beam(30, E, I)\n+        >>> b.apply_load(-8, 0, -1)\n+        >>> b.apply_load(R1, 10, -1)\n+        >>> b.apply_load(R2, 30, -1)\n+        >>> b.apply_load(120, 30, -2)\n+        >>> b.bc_deflection = [(10, 0), (30, 0)]\n+        >>> b.solve_for_reaction_loads(R1, R2)\n+        >>> b.slope()\n+        (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)\n+            + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)\n+        \"\"\"\n+=======\n     def slope(self):\n         \"\"\"\n         Returns a Singularity Function expression which represents\n@@ -817,6 +843,31 @@ def slope(self):\n         Using the sign convention of upward forces and clockwise moment\n         being positive.\n \n+        >>> from sympy.physics.continuum_mechanics.beam import Beam\n+        >>> from sympy import symbols\n+        >>> E, I = symbols('E, I')\n+        >>> R1, R2 = symbols('R1, R2')\n+        >>> b = Beam(30, E, I)\n+        >>> b.apply_load(-8, 0, -1)\n+        >>> b.apply_load(R1, 10, -1)\n+        >>> b.apply_load(R2, 30, -1)\n+        >>> b.apply_load(120, 30, -2)\n+        >>> b.bc_deflection = [(10, 0), (30, 0)]\n+        >>> b.solve_for_reaction_loads(R1, R2)\n+        >>> b.slope()\n+        (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)\n+            + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)\n+        \"\"\"=======\n+        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n+        applied in the clockwise direction at the end of the beam. A pointload\n+        of magnitude 8 N is applied from the top of the beam at the starting\n+        point. There are two simple supports below the beam. One at the end\n+        and another one at a distance of 10 meters from the start. The\n+        deflection is restricted at both the supports.\n+\n+        Using the sign convention of upward forces and clockwise moment\n+        being positive.\n+\n         >>> from sympy.physics.continuum_mechanics.beam import Beam\n         >>> from sympy import symbols\n         >>> E, I = symbols('E, I')\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 0545797d5f..5b276cc508 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -825,7 +825,7 @@ def _print_MatAdd(self, expr):\n             if s is None:\n                 s = pform     # First element\n             else:\n-                if S(item.args[0]).is_negative:\n+                if item.args and item.args[0].is_number and item.args[0].is_negative:\n                     s = prettyForm(*stringPict.next(s, ' '))\n                     pform = self._print(item)\n                 else:\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}