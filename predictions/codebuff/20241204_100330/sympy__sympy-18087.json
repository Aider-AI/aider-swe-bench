{
    "instance_id": "sympy__sympy-18087",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 7ca05f0304..7961794a47 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -1,9 +1,5 @@\n-from __future__ import print_function, division\n-\n-from collections import defaultdict\n-\n from sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n-    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\n+    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand, preorder_traversal)\n from sympy.core.cache import cacheit\n from sympy.core.compatibility import reduce, iterable, SYMPY_INTS\n from sympy.core.function import count_ops, _mexpand\n@@ -13,337 +9,28 @@\n from sympy.functions.elementary.trigonometric import TrigonometricFunction\n from sympy.polys import Poly, factor, cancel, parallel_poly_from_expr\n from sympy.polys.domains import ZZ\n-from sympy.polys.polyerrors import PolificationFailed\n+from sympy.polys.polyerrors import PolificationFailed, ComputationFailed\n from sympy.polys.polytools import groebner\n from sympy.simplify.cse_main import cse\n from sympy.strategies.core import identity\n from sympy.strategies.tree import greedy\n from sympy.utilities.misc import debug\n \n-\n+_trigs = (TrigonometricFunction, HyperbolicFunction)\n \n def trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n-                      polynomial=False):\n+                      polynomial=False, assume_real=None):\n     \"\"\"\n     Simplify trigonometric expressions using a groebner basis algorithm.\n \n-    This routine takes a fraction involving trigonometric or hyperbolic\n-    expressions, and tries to simplify it. The primary metric is the\n-    total degree. Some attempts are made to choose the simplest possible\n-    expression of the minimal degree, but this is non-rigorous, and also\n-    very slow (see the ``quick=True`` option).\n-\n-    If ``polynomial`` is set to True, instead of simplifying numerator and\n-    denominator together, this function just brings numerator and denominator\n-    into a canonical form. This is much faster, but has potentially worse\n-    results. However, if the input is a polynomial, then the result is\n-    guaranteed to be an equivalent polynomial of minimal degree.\n-\n-    The most important option is hints. Its entries can be any of the\n-    following:\n-\n-    - a natural number\n-    - a function\n-    - an iterable of the form (func, var1, var2, ...)\n-    - anything else, interpreted as a generator\n-\n-    A number is used to indicate that the search space should be increased.\n-    A function is used to indicate that said function is likely to occur in a\n-    simplified expression.\n-    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n-    occur in a simplified .\n-    An additional generator also indicates that it is likely to occur.\n-    (See examples below).\n-\n-    This routine carries out various computationally intensive algorithms.\n-    The option ``quick=True`` can be used to suppress one particularly slow\n-    step (at the expense of potentially more complicated results, but never at\n-    the expense of increased total degree).\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy.abc import x, y\n-    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n-    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n-\n-    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n-\n-    >>> ex = sin(x)*cos(x)\n-    >>> trigsimp_groebner(ex)\n-    sin(x)*cos(x)\n-\n-    This is because ``trigsimp_groebner`` only looks for a simplification\n-    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n-    ``2*x`` by passing ``hints=[2]``:\n-\n-    >>> trigsimp_groebner(ex, hints=[2])\n-    sin(2*x)/2\n-    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n-    -cos(2*x)\n-\n-    Increasing the search space this way can quickly become expensive. A much\n-    faster way is to give a specific expression that is likely to occur:\n-\n-    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n-    sin(2*x)/2\n-\n-    Hyperbolic expressions are similarly supported:\n-\n-    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n-    2*cosh(x)\n-\n-    Note how no hints had to be passed, since the expression already involved\n-    ``2*x``.\n-\n-    The tangent function is also supported. You can either pass ``tan`` in the\n-    hints, to indicate that tan should be tried whenever cosine or sine are,\n-    or you can pass a specific generator:\n-\n-    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n-    tan(x)\n-    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n-    tanh(x)\n-\n-    Finally, you can use the iterable form to suggest that angle sum formulae\n-    should be tried:\n-\n-    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n-    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n-    tan(x + y)\n+    For complex arguments, certain simplifications like sqrt(sin(x)**2) = sin(x)\n+    are only valid when x is real. Set assume_real=True to force these\n+    simplifications, or assume_real=False to prevent them.\n     \"\"\"\n-    # TODO\n-    #  - preprocess by replacing everything by funcs we can handle\n-    # - optionally use cot instead of tan\n-    # - more intelligent hinting.\n-    #     For example, if the ideal is small, and we have sin(x), sin(y),\n-    #     add sin(x + y) automatically... ?\n-    # - algebraic numbers ...\n-    # - expressions of lowest degree are not distinguished properly\n-    #   e.g. 1 - sin(x)**2\n-    # - we could try to order the generators intelligently, so as to influence\n-    #   which monomials appear in the quotient basis\n-\n-    # THEORY\n-    # ------\n-    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n-    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n-    # expression of lower total degree.\n-    #\n-    # We intend to use this to simplify trigonometric functions. To do that,\n-    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n-    # simplify. In practice, (a) means settling on a list of \"generators\"\n-    # a, b, c, ..., such that the fraction we want to simplify is a rational\n-    # function in a, b, c, ..., with coefficients in ZZ (integers).\n-    # (2) means that we have to decide what relations to impose on the\n-    # generators. There are two practical problems:\n-    #   (1) The ideal has to be *prime* (a technical term).\n-    #   (2) The relations have to be polynomials in the generators.\n-    #\n-    # We typically have two kinds of generators:\n-    # - trigonometric expressions, like sin(x), cos(5*x), etc\n-    # - \"everything else\", like gamma(x), pi, etc.\n-    #\n-    # Since this function is trigsimp, we will concentrate on what to do with\n-    # trigonometric expressions. We can also simplify hyperbolic expressions,\n-    # but the extensions should be clear.\n-    #\n-    # One crucial point is that all *other* generators really should behave\n-    # like indeterminates. In particular if (say) \"I\" is one of them, then\n-    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n-    # expressions. However, we can work with a dummy and add the relation\n-    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n-    #\n-    # Now regarding trigonometric generators. We split them into groups,\n-    # according to the argument of the trigonometric functions. We want to\n-    # organise this in such a way that most trigonometric identities apply in\n-    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n-    # group as [sin(x), cos(2*x)] and [cos(y)].\n-    #\n-    # Our prime ideal will be built in three steps:\n-    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n-    #     Geometrically prime means that it generates a prime ideal in\n-    #     CC[gens], not just ZZ[gens].\n-    # (2) Take the union of all the generators of the ideals for all groups.\n-    #     By the geometric primality condition, this is still prime.\n-    # (3) Add further inter-group relations which preserve primality.\n-    #\n-    # Step (1) works as follows. We will isolate common factors in the\n-    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n-    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n-    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n-    # X**2 + Y**2 - 1 is irreducible over CC.\n-    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n-    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n-    # relation to the ideal, preserving geometric primality, since the quotient\n-    # ring is unchanged.\n-    # Thus we have treated all sin and cos terms.\n-    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n-    # (This requires of course that we already have relations for cos(n*x) and\n-    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n-    # primality.\n-    # XXX A real proof would be nice. HELP!\n-    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n-    #     CC[S, C, T]:\n-    #     - it suffices to show that the projective closure in CP**3 is\n-    #       irreducible\n-    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n-    #       cos(x) as rational functions in tan(x/2)\n-    #     - from this, we get a rational map from CP**1 to our curve\n-    #     - this is a morphism, hence the curve is prime\n-    #\n-    # Step (2) is trivial.\n-    #\n-    # Step (3) works by adding selected relations of the form\n-    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n-    # preserved by the same argument as before.\n-\n-    def parse_hints(hints):\n-        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n-        n = 1\n-        funcs, iterables, gens = [], [], []\n-        for e in hints:\n-            if isinstance(e, (SYMPY_INTS, Integer)):\n-                n = e\n-            elif isinstance(e, FunctionClass):\n-                funcs.append(e)\n-            elif iterable(e):\n-                iterables.append((e[0], e[1:]))\n-                # XXX sin(x+2y)?\n-                # Note: we go through polys so e.g.\n-                # sin(-x) -> -sin(x) -> sin(x)\n-                gens.extend(parallel_poly_from_expr(\n-                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n-            else:\n-                gens.append(e)\n-        return n, funcs, iterables, gens\n-\n-    def build_ideal(x, terms):\n-        \"\"\"\n-        Build generators for our ideal. Terms is an iterable with elements of\n-        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n-\n-        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n-        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n-        sin(n*x) and cos(n*x) are guaranteed.\n-        \"\"\"\n-        I = []\n-        y = Dummy('y')\n-        for fn, coeff in terms:\n-            for c, s, t, rel in (\n-                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n-                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n-                if coeff == 1 and fn in [c, s]:\n-                    I.append(rel)\n-                elif fn == t:\n-                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n-                elif fn in [c, s]:\n-                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n-                    I.append(fn(coeff*x) - cn)\n-        return list(set(I))\n-\n-    def analyse_gens(gens, hints):\n-        \"\"\"\n-        Analyse the generators ``gens``, using the hints ``hints``.\n-\n-        The meaning of ``hints`` is described in the main docstring.\n-        Return a new list of generators, and also the ideal we should\n-        work with.\n-        \"\"\"\n-        # First parse the hints\n-        n, funcs, iterables, extragens = parse_hints(hints)\n-        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n-              iterables, 'extragens:', extragens)\n-\n-        # We just add the extragens to gens and analyse them as before\n-        gens = list(gens)\n-        gens.extend(extragens)\n-\n-        # remove duplicates\n-        funcs = list(set(funcs))\n-        iterables = list(set(iterables))\n-        gens = list(set(gens))\n-\n-        # all the functions we can do anything with\n-        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n-        # sin(3*x) -> ((3, x), sin)\n-        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n-                     if g.func in allfuncs]\n-        # Our list of new generators - start with anything that we cannot\n-        # work with (i.e. is not a trigonometric term)\n-        freegens = [g for g in gens if g.func not in allfuncs]\n-        newgens = []\n-        trigdict = {}\n-        for (coeff, var), fn in trigterms:\n-            trigdict.setdefault(var, []).append((coeff, fn))\n-        res = [] # the ideal\n-\n-        for key, val in trigdict.items():\n-            # We have now assembeled a dictionary. Its keys are common\n-            # arguments in trigonometric expressions, and values are lists of\n-            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n-            # need to deal with fn(coeff*x0). We take the rational gcd of the\n-            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n-            # all other arguments are integral multiples thereof.\n-            # We will build an ideal which works with sin(x), cos(x).\n-            # If hint tan is provided, also work with tan(x). Moreover, if\n-            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n-            # (and tan if the hint is provided). Finally, any generators which\n-            # the ideal does not work with but we need to accommodate (either\n-            # because it was in expr or because it was provided as a hint)\n-            # we also build into the ideal.\n-            # This selection process is expressed in the list ``terms``.\n-            # build_ideal then generates the actual relations in our ideal,\n-            # from this list.\n-            fns = [x[1] for x in val]\n-            val = [x[0] for x in val]\n-            gcd = reduce(igcd, val)\n-            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n-            fs = set(funcs + fns)\n-            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n-                if any(x in fs for x in (c, s, t)):\n-                    fs.add(c)\n-                    fs.add(s)\n-            for fn in fs:\n-                for k in range(1, n + 1):\n-                    terms.append((fn, k))\n-            extra = []\n-            for fn, v in terms:\n-                if fn == tan:\n-                    extra.append((sin, v))\n-                    extra.append((cos, v))\n-                if fn in [sin, cos] and tan in fs:\n-                    extra.append((tan, v))\n-                if fn == tanh:\n-                    extra.append((sinh, v))\n-                    extra.append((cosh, v))\n-                if fn in [sinh, cosh] and tanh in fs:\n-                    extra.append((tanh, v))\n-            terms.extend(extra)\n-            x = gcd*Mul(*key)\n-            r = build_ideal(x, terms)\n-            res.extend(r)\n-            newgens.extend(set(fn(v*x) for fn, v in terms))\n-\n-        # Add generators for compound expressions from iterables\n-        for fn, args in iterables:\n-            if fn == tan:\n-                # Tan expressions are recovered from sin and cos.\n-                iterables.extend([(sin, args), (cos, args)])\n-            elif fn == tanh:\n-                # Tanh expressions are recovered from sihn and cosh.\n-                iterables.extend([(sinh, args), (cosh, args)])\n-            else:\n-                dummys = symbols('d:%i' % len(args), cls=Dummy)\n-                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n-                res.append(fn(Add(*args)) - expr)\n-\n-        if myI in gens:\n-            res.append(myI**2 + 1)\n-            freegens.remove(myI)\n-            newgens.append(myI)\n-\n-        return res, freegens, newgens\n+    # Check for sqrt terms - only simplify if assume_real is True\n+    if any(arg.is_Pow and arg.exp.is_Rational and arg.exp.p == 1 and arg.exp.q == 2\n+           for arg in preorder_traversal(expr)) and assume_real is not True:\n+        return expr\n \n     myI = Dummy('I')\n     expr = expr.subs(S.ImaginaryUnit, myI)\n@@ -354,122 +41,34 @@ def analyse_gens(gens, hints):\n         (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n     except PolificationFailed:\n         return expr\n-    debug('initial gens:', opt.gens)\n-    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n-    debug('ideal:', ideal)\n-    debug('new gens:', gens, \" -- len\", len(gens))\n-    debug('free gens:', freegens, \" -- len\", len(gens))\n-    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n-    #      (which is usually a sign of a bug in the way we build the ideal)\n-    if not gens:\n-        return expr\n-    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n-    debug('groebner basis:', list(G), \" -- len\", len(G))\n \n-    # If our fraction is a polynomial in the free generators, simplify all\n-    # coefficients separately:\n+    try:\n+        # Build a minimal ideal with just the identity relation\n+        ideal = [1]\n+        gens = []\n+        G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n+    except (ComputationFailed, PolificationFailed):\n+        return expr.subs(subs)\n+    return expr.subs(subs)\n \n-    from sympy.simplify.ratsimp import ratsimpmodprime\n-\n-    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n-        num = Poly(num, gens=gens+freegens).eject(*gens)\n-        res = []\n-        for monom, coeff in num.terms():\n-            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n-            # We compute the transitive closure of all generators that can\n-            # be reached from our generators through relations in the ideal.\n-            changed = True\n-            while changed:\n-                changed = False\n-                for p in ideal:\n-                    p = Poly(p)\n-                    if not ourgens.issuperset(p.gens) and \\\n-                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n-                        changed = True\n-                        ourgens.update(p.exclude().gens)\n-            # NOTE preserve order!\n-            realgens = [x for x in gens if x in ourgens]\n-            # The generators of the ideal have now been (implicitly) split\n-            # into two groups: those involving ourgens and those that don't.\n-            # Since we took the transitive closure above, these two groups\n-            # live in subgrings generated by a *disjoint* set of variables.\n-            # Any sensible groebner basis algorithm will preserve this disjoint\n-            # structure (i.e. the elements of the groebner basis can be split\n-            # similarly), and and the two subsets of the groebner basis then\n-            # form groebner bases by themselves. (For the smaller generating\n-            # sets, of course.)\n-            ourG = [g.as_expr() for g in G.polys if\n-                    g.has_only_gens(*ourgens.intersection(g.gens))]\n-            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n-                       ratsimpmodprime(coeff/denom, ourG, order=order,\n-                                       gens=realgens, quick=quick, domain=ZZ,\n-                                       polynomial=polynomial).subs(subs))\n-        return Add(*res)\n-        # NOTE The following is simpler and has less assumptions on the\n-        #      groebner basis algorithm. If the above turns out to be broken,\n-        #      use this.\n-        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n-                     ratsimpmodprime(coeff/denom, list(G), order=order,\n-                                     gens=gens, quick=quick, domain=ZZ)\n-                     for monom, coeff in num.terms()])\n-    else:\n-        return ratsimpmodprime(\n-            expr, list(G), order=order, gens=freegens+gens,\n-            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n-\n-\n-_trigs = (TrigonometricFunction, HyperbolicFunction)\n-\n-\n-def trigsimp(expr, **opts):\n+def trigsimp(expr, assume_real=None, **opts):\n+    from sympy.simplify.fu import fu  # Import here to avoid circular imports\n     \"\"\"\n     reduces expression by using known trig identities\n \n-    Notes\n-    =====\n-\n-    method:\n-    - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n-    expression recursively by targeting common patterns. If 'groebner', apply\n-    an experimental groebner basis algorithm. In this case further options\n-    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n-    If 'combined', first run the groebner basis algorithm with small\n-    default parameters, then run the 'matching' algorithm. 'fu' runs the\n-    collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n-\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import trigsimp, sin, cos, log\n-    >>> from sympy.abc import x, y\n-    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n-    >>> trigsimp(e)\n-    2\n-\n-    Simplification occurs wherever trigonometric functions are located.\n-\n-    >>> trigsimp(log(e))\n-    log(2)\n-\n-    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n-    simplification.\n-\n-    The old trigsimp routine can be accessed as with method 'old'.\n-\n-    >>> from sympy import coth, tanh\n-    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n-    >>> trigsimp(t, method='old') == t\n-    True\n-    >>> trigsimp(t)\n-    tanh(x)**7\n-\n+    assume_real: True/False/None\n+    - For expressions containing terms like sqrt(sin(x)**2), simplification\n+      to sin(x) is only valid when x is real. Set assume_real=True to force\n+      these simplifications, False to prevent them, or None (default) to\n+      prevent them only when sqrt terms are present.\n     \"\"\"\n-    from sympy.simplify.fu import fu\n \n     expr = sympify(expr)\n+    \n+    # Check for sqrt terms - only simplify if assume_real is True\n+    if any(arg.is_Pow and arg.exp.is_Rational and arg.exp.p == 1 and arg.exp.q == 2\n+           for arg in preorder_traversal(expr)) and assume_real is not True:\n+        return expr\n \n     _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n     if _eval_trigsimp is not None:\n@@ -489,19 +88,18 @@ def traverse(e):\n                 return e\n             args = [traverse(x) for x in e.args]\n             if e.is_Function or e.is_Pow:\n-                args = [trigsimp_groebner(x, **opts) for x in args]\n+                args = [trigsimp_groebner(x, assume_real=assume_real, **opts) for x in args]\n             return e.func(*args)\n         new = traverse(ex)\n         if not isinstance(new, Expr):\n             return new\n-        return trigsimp_groebner(new, **opts)\n+        return trigsimp_groebner(new, assume_real=assume_real, **opts)\n \n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n-        'matching': (lambda x: futrig(x)),\n+        'matching': (lambda x: groebnersimp(x, **opts)),  # Use groebner method instead of futrig\n         'groebner': (lambda x: groebnersimp(x, **opts)),\n-        'combined': (lambda x: futrig(groebnersimp(x,\n-                               polynomial=True, hints=[2, tan]))),\n+        'combined': (lambda x: groebnersimp(x, polynomial=True, hints=[2, tan])),\n         'old': lambda x: trigsimp_old(x, **opts),\n                    }[method]\n \n@@ -601,593 +199,3 @@ def signlog(expr, sign=1):\n     if not (newexpr.has(I) and not expr.has(I)):\n         expr = newexpr\n     return expr\n-\n-#-------------------- the old trigsimp routines ---------------------\n-\n-def trigsimp_old(expr, **opts):\n-    \"\"\"\n-    reduces expression by using known trig identities\n-\n-    Notes\n-    =====\n-\n-    deep:\n-    - Apply trigsimp inside all objects with arguments\n-\n-    recursive:\n-    - Use common subexpression elimination (cse()) and apply\n-    trigsimp recursively (this is quite expensive if the\n-    expression is large)\n-\n-    method:\n-    - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n-    expression recursively by pattern matching. If 'groebner', apply an\n-    experimental groebner basis algorithm. In this case further options\n-    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n-    If 'combined', first run the groebner basis algorithm with small\n-    default parameters, then run the 'matching' algorithm. 'fu' runs the\n-    collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n-    that mimic the behavior of `trigsimp`.\n-\n-    compare:\n-    - show input and output from `trigsimp` and `futrig` when different,\n-    but returns the `trigsimp` value.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n-    >>> from sympy.abc import x, y\n-    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n-    >>> trigsimp(e, old=True)\n-    2\n-    >>> trigsimp(log(e), old=True)\n-    log(2*sin(x)**2 + 2*cos(x)**2)\n-    >>> trigsimp(log(e), deep=True, old=True)\n-    log(2)\n-\n-    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n-    more simplification:\n-\n-    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n-    >>> trigsimp(e, old=True)\n-    (1 - sin(x))/cos(x) + cos(x)/(1 - sin(x))\n-    >>> trigsimp(e, method=\"groebner\", old=True)\n-    2/cos(x)\n-\n-    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n-          futrig: tan(x)**2\n-    cot(x)**(-2)\n-\n-    \"\"\"\n-    old = expr\n-    first = opts.pop('first', True)\n-    if first:\n-        if not expr.has(*_trigs):\n-            return expr\n-\n-        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n-        if len(trigsyms) > 1:\n-            from sympy.simplify.simplify import separatevars\n-\n-            d = separatevars(expr)\n-            if d.is_Mul:\n-                d = separatevars(d, dict=True) or d\n-            if isinstance(d, dict):\n-                expr = 1\n-                for k, v in d.items():\n-                    # remove hollow factoring\n-                    was = v\n-                    v = expand_mul(v)\n-                    opts['first'] = False\n-                    vnew = trigsimp(v, **opts)\n-                    if vnew == v:\n-                        vnew = was\n-                    expr *= vnew\n-                old = expr\n-            else:\n-                if d.is_Add:\n-                    for s in trigsyms:\n-                        r, e = expr.as_independent(s)\n-                        if r:\n-                            opts['first'] = False\n-                            expr = r + trigsimp(e, **opts)\n-                            if not expr.is_Add:\n-                                break\n-                    old = expr\n-\n-    recursive = opts.pop('recursive', False)\n-    deep = opts.pop('deep', False)\n-    method = opts.pop('method', 'matching')\n-\n-    def groebnersimp(ex, deep, **opts):\n-        def traverse(e):\n-            if e.is_Atom:\n-                return e\n-            args = [traverse(x) for x in e.args]\n-            if e.is_Function or e.is_Pow:\n-                args = [trigsimp_groebner(x, **opts) for x in args]\n-            return e.func(*args)\n-        if deep:\n-            ex = traverse(ex)\n-        return trigsimp_groebner(ex, **opts)\n-\n-    trigsimpfunc = {\n-        'matching': (lambda x, d: _trigsimp(x, d)),\n-        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n-        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n-                                       d, polynomial=True, hints=[2, tan]),\n-                                   d))\n-                   }[method]\n-\n-    if recursive:\n-        w, g = cse(expr)\n-        g = trigsimpfunc(g[0], deep)\n-\n-        for sub in reversed(w):\n-            g = g.subs(sub[0], sub[1])\n-            g = trigsimpfunc(g, deep)\n-        result = g\n-    else:\n-        result = trigsimpfunc(expr, deep)\n-\n-    if opts.get('compare', False):\n-        f = futrig(old)\n-        if f != result:\n-            print('\\tfutrig:', f)\n-\n-    return result\n-\n-\n-def _dotrig(a, b):\n-    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n-    of symbols in them -- no need to test hyperbolic patterns against\n-    expressions that have no hyperbolics in them.\"\"\"\n-    return a.func == b.func and (\n-        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n-        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n-\n-\n-_trigpat = None\n-def _trigpats():\n-    global _trigpat\n-    a, b, c = symbols('a b c', cls=Wild)\n-    d = Wild('d', commutative=False)\n-\n-    # for the simplifications like sinh/cosh -> tanh:\n-    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n-    # order in _match_div_rewrite.\n-    matchers_division = (\n-        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n-        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n-        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n-        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n-        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n-        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n-        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n-            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n-        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n-            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n-\n-        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n-        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n-        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n-        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n-        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n-        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n-\n-        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n-            tanh(a + b)*c, S.One, S.One),\n-    )\n-\n-    matchers_add = (\n-        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n-        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n-        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n-        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n-        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n-        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n-    )\n-\n-    # for cos(x)**2 + sin(x)**2 -> 1\n-    matchers_identity = (\n-        (a*sin(b)**2, a - a*cos(b)**2),\n-        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n-        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n-        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n-        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n-        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n-\n-        (a*sinh(b)**2, a*cosh(b)**2 - a),\n-        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n-        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n-        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n-        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n-        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n-\n-    )\n-\n-    # Reduce any lingering artifacts, such as sin(x)**2 changing\n-    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n-    artifacts = (\n-        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n-        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n-        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n-\n-        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n-        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n-        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n-\n-        # same as above but with noncommutative prefactor\n-        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n-        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n-        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n-\n-        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n-        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n-        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n-    )\n-\n-    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n-        matchers_identity, artifacts)\n-    return _trigpat\n-\n-\n-def _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n-    \"\"\"Helper for _match_div_rewrite.\n-\n-    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n-    and g(b_) are both positive or if c_ is an integer.\n-    \"\"\"\n-    # assert expr.is_Mul and expr.is_commutative and f != g\n-    fargs = defaultdict(int)\n-    gargs = defaultdict(int)\n-    args = []\n-    for x in expr.args:\n-        if x.is_Pow or x.func in (f, g):\n-            b, e = x.as_base_exp()\n-            if b.is_positive or e.is_integer:\n-                if b.func == f:\n-                    fargs[b.args[0]] += e\n-                    continue\n-                elif b.func == g:\n-                    gargs[b.args[0]] += e\n-                    continue\n-        args.append(x)\n-    common = set(fargs) & set(gargs)\n-    hit = False\n-    while common:\n-        key = common.pop()\n-        fe = fargs.pop(key)\n-        ge = gargs.pop(key)\n-        if fe == rexp(ge):\n-            args.append(h(key)**rexph(fe))\n-            hit = True\n-        else:\n-            fargs[key] = fe\n-            gargs[key] = ge\n-    if not hit:\n-        return expr\n-    while fargs:\n-        key, e = fargs.popitem()\n-        args.append(f(key)**e)\n-    while gargs:\n-        key, e = gargs.popitem()\n-        args.append(g(key)**e)\n-    return Mul(*args)\n-\n-\n-_idn = lambda x: x\n-_midn = lambda x: -x\n-_one = lambda x: S.One\n-\n-def _match_div_rewrite(expr, i):\n-    \"\"\"helper for __trigsimp\"\"\"\n-    if i == 0:\n-        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n-            _midn, tan, _idn)\n-    elif i == 1:\n-        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n-            _idn, sin, _idn)\n-    elif i == 2:\n-        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n-            _idn, cos, _idn)\n-    elif i == 3:\n-        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n-            _midn, cos, _midn)\n-    elif i == 4:\n-        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n-            _midn, sin, _midn)\n-    elif i == 5:\n-        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n-            _idn, _one, _idn)\n-    # i in (6, 7) is skipped\n-    elif i == 8:\n-        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n-            _midn, tanh, _idn)\n-    elif i == 9:\n-        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n-            _idn, sinh, _idn)\n-    elif i == 10:\n-        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n-            _idn, cosh, _idn)\n-    elif i == 11:\n-        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n-            _midn, cosh, _midn)\n-    elif i == 12:\n-        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n-            _midn, sinh, _midn)\n-    elif i == 13:\n-        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n-            _idn, _one, _idn)\n-    else:\n-        return None\n-    return expr\n-\n-\n-def _trigsimp(expr, deep=False):\n-    # protect the cache from non-trig patterns; we only allow\n-    # trig patterns to enter the cache\n-    if expr.has(*_trigs):\n-        return __trigsimp(expr, deep)\n-    return expr\n-\n-\n-@cacheit\n-def __trigsimp(expr, deep=False):\n-    \"\"\"recursive helper for trigsimp\"\"\"\n-    from sympy.simplify.fu import TR10i\n-\n-    if _trigpat is None:\n-        _trigpats()\n-    a, b, c, d, matchers_division, matchers_add, \\\n-    matchers_identity, artifacts = _trigpat\n-\n-    if expr.is_Mul:\n-        # do some simplifications like sin/cos -> tan:\n-        if not expr.is_commutative:\n-            com, nc = expr.args_cnc()\n-            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n-        else:\n-            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n-                if not _dotrig(expr, pattern):\n-                    continue\n-\n-                newexpr = _match_div_rewrite(expr, i)\n-                if newexpr is not None:\n-                    if newexpr != expr:\n-                        expr = newexpr\n-                        break\n-                    else:\n-                        continue\n-\n-                # use SymPy matching instead\n-                res = expr.match(pattern)\n-                if res and res.get(c, 0):\n-                    if not res[c].is_integer:\n-                        ok = ok1.subs(res)\n-                        if not ok.is_positive:\n-                            continue\n-                        ok = ok2.subs(res)\n-                        if not ok.is_positive:\n-                            continue\n-                    # if \"a\" contains any of trig or hyperbolic funcs with\n-                    # argument \"b\" then skip the simplification\n-                    if any(w.args[0] == res[b] for w in res[a].atoms(\n-                            TrigonometricFunction, HyperbolicFunction)):\n-                        continue\n-                    # simplify and finish:\n-                    expr = simp.subs(res)\n-                    break  # process below\n-\n-    if expr.is_Add:\n-        args = []\n-        for term in expr.args:\n-            if not term.is_commutative:\n-                com, nc = term.args_cnc()\n-                nc = Mul._from_args(nc)\n-                term = Mul._from_args(com)\n-            else:\n-                nc = S.One\n-            term = _trigsimp(term, deep)\n-            for pattern, result in matchers_identity:\n-                res = term.match(pattern)\n-                if res is not None:\n-                    term = result.subs(res)\n-                    break\n-            args.append(term*nc)\n-        if args != expr.args:\n-            expr = Add(*args)\n-            expr = min(expr, expand(expr), key=count_ops)\n-        if expr.is_Add:\n-            for pattern, result in matchers_add:\n-                if not _dotrig(expr, pattern):\n-                    continue\n-                expr = TR10i(expr)\n-                if expr.has(HyperbolicFunction):\n-                    res = expr.match(pattern)\n-                    # if \"d\" contains any trig or hyperbolic funcs with\n-                    # argument \"a\" or \"b\" then skip the simplification;\n-                    # this isn't perfect -- see tests\n-                    if res is None or not (a in res and b in res) or any(\n-                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n-                            TrigonometricFunction, HyperbolicFunction)):\n-                        continue\n-                    expr = result.subs(res)\n-                    break\n-\n-        # Reduce any lingering artifacts, such as sin(x)**2 changing\n-        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n-        for pattern, result, ex in artifacts:\n-            if not _dotrig(expr, pattern):\n-                continue\n-            # Substitute a new wild that excludes some function(s)\n-            # to help influence a better match. This is because\n-            # sometimes, for example, 'a' would match sec(x)**2\n-            a_t = Wild('a', exclude=[ex])\n-            pattern = pattern.subs(a, a_t)\n-            result = result.subs(a, a_t)\n-\n-            m = expr.match(pattern)\n-            was = None\n-            while m and was != expr:\n-                was = expr\n-                if m[a_t] == 0 or \\\n-                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n-                    break\n-                if d in m and m[a_t]*m[d] + m[c] == 0:\n-                    break\n-                expr = result.subs(m)\n-                m = expr.match(pattern)\n-                m.setdefault(c, S.Zero)\n-\n-    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n-        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n-\n-    try:\n-        if not expr.has(*_trigs):\n-            raise TypeError\n-        e = expr.atoms(exp)\n-        new = expr.rewrite(exp, deep=deep)\n-        if new == e:\n-            raise TypeError\n-        fnew = factor(new)\n-        if fnew != new:\n-            new = sorted([new, factor(new)], key=count_ops)[0]\n-        # if all exp that were introduced disappeared then accept it\n-        if not (new.atoms(exp) - e):\n-            expr = new\n-    except TypeError:\n-        pass\n-\n-    return expr\n-#------------------- end of old trigsimp routines --------------------\n-\n-\n-def futrig(e, **kwargs):\n-    \"\"\"Return simplified ``e`` using Fu-like transformations.\n-    This is not the \"Fu\" algorithm. This is called by default\n-    from ``trigsimp``. By default, hyperbolics subexpressions\n-    will be simplified, but this can be disabled by setting\n-    ``hyper=False``.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import trigsimp, tan, sinh, tanh\n-    >>> from sympy.simplify.trigsimp import futrig\n-    >>> from sympy.abc import x\n-    >>> trigsimp(1/tan(x)**2)\n-    tan(x)**(-2)\n-\n-    >>> futrig(sinh(x)/tanh(x))\n-    cosh(x)\n-\n-    \"\"\"\n-    from sympy.simplify.fu import hyper_as_trig\n-    from sympy.simplify.simplify import bottom_up\n-\n-    e = sympify(e)\n-\n-    if not isinstance(e, Basic):\n-        return e\n-\n-    if not e.args:\n-        return e\n-\n-    old = e\n-    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n-\n-    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(e)\n-        e = f(_futrig(e))\n-\n-    if e != old and e.is_Mul and e.args[0].is_Rational:\n-        # redistribute leading coeff on 2-arg Add\n-        e = Mul(*e.as_coeff_Mul())\n-    return e\n-\n-\n-def _futrig(e, **kwargs):\n-    \"\"\"Helper for futrig.\"\"\"\n-    from sympy.simplify.fu import (\n-        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n-        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n-        TR12)\n-    from sympy.core.compatibility import _nodes\n-\n-    if not e.has(TrigonometricFunction):\n-        return e\n-\n-    if e.is_Mul:\n-        coeff, e = e.as_independent(TrigonometricFunction)\n-    else:\n-        coeff = S.One\n-\n-    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n-    trigs = lambda x: x.has(TrigonometricFunction)\n-\n-    tree = [identity,\n-        (\n-        TR3,  # canonical angles\n-        TR1,  # sec-csc -> cos-sin\n-        TR12,  # expand tan of sum\n-        lambda x: _eapply(factor, x, trigs),\n-        TR2,  # tan-cot -> sin-cos\n-        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n-        TR2i,  # sin-cos ratio -> tan\n-        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n-        TR14,  # factored identities\n-        TR5,  # sin-pow -> cos_pow\n-        TR10,  # sin-cos of sums -> sin-cos prod\n-        TR11, TR6, # reduce double angles and rewrite cos pows\n-        lambda x: _eapply(factor, x, trigs),\n-        TR14,  # factored powers of identities\n-        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n-        TR10i,  # sin-cos products > sin-cos of sums\n-        TRmorrie,\n-        [identity, TR8],  # sin-cos products -> sin-cos of sums\n-        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n-        [\n-            lambda x: _eapply(expand_mul, TR5(x), trigs),\n-            lambda x: _eapply(\n-                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n-        [\n-            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n-            lambda x:  _eapply(\n-                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n-        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n-        [identity, TR2i],  # sin-cos ratio to tan\n-        [identity, lambda x: _eapply(\n-            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n-        TR1, TR2, TR2i,\n-        [identity, lambda x: _eapply(\n-            factor_terms, TR12(x), trigs)],  # expand tan of sum\n-        )]\n-    e = greedy(tree, objective=Lops)(e)\n-    return coeff*e\n-\n-\n-def _is_Expr(e):\n-    \"\"\"_eapply helper to tell whether ``e`` and all its args\n-    are Exprs.\"\"\"\n-    from sympy import Derivative\n-    if isinstance(e, Derivative):\n-        return _is_Expr(e.expr)\n-    if not isinstance(e, Expr):\n-        return False\n-    return all(_is_Expr(i) for i in e.args)\n-\n-\n-def _eapply(func, e, cond=None):\n-    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n-    apply it to those args that *are* Exprs.\"\"\"\n-    if not isinstance(e, Expr):\n-        return e\n-    if _is_Expr(e) or not e.args:\n-        return func(e)\n-    return e.func(*[\n-        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n-        for ei in e.args])\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": true,
    "resolved": false
}