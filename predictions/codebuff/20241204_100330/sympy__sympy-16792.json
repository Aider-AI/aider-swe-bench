{
    "instance_id": "sympy__sympy-16792",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/utilities/autowrap.py b/sympy/utilities/autowrap.py\nindex bd6afb12d1..44f987a602 100644\n--- a/sympy/utilities/autowrap.py\n+++ b/sympy/utilities/autowrap.py\n@@ -257,6 +257,31 @@ class CythonCodeWrapper(CodeWrapper):\n \n     std_compile_flag = '-std=c99'\n \n+\n+        include_dirs : [list of strings]\n+            A list of directories to search for C/C++ header files (in Unix\n+            form for portability).\n+        library_dirs : [list of strings]\n+            A list of directories to search for C/C++ libraries at link time.\n+        libraries : [list of strings]\n+            A list of library names (not filenames or paths) to link against.\n+        extra_compile_args : [list of strings]\n+            Any extra platform- and compiler-specific information to use when\n+            compiling the source files in 'sources'.  For platforms and\n+            compilers where \"command line\" makes sense, this is typically a\n+            list of command-line arguments, but for other platforms it could be\n+            anything. Note that the attribute ``std_compile_flag`` will be\n+            appended to this list.\n+        extra_link_args : [list of strings]\n+            Any extra platform- and compiler-specific information to use when\n+            linking object files together to create the extension (or to create\n+            a new static Python interpreter). Similar interpretation as for\n+            'extra_compile_args'.\n+        cythonize_options : [dictionary]\n+            Keyword arguments passed on to cythonize.\n+\n+        \"\"\"\n+=======\n     def __init__(self, *args, **kwargs):\n         \"\"\"Instantiates a Cython code wrapper.\n \n@@ -266,6 +291,32 @@ def __init__(self, *args, **kwargs):\n \n         Parameters\n         ==========\n+\n+        include_dirs : [list of strings]\n+            A list of directories to search for C/C++ header files (in Unix\n+            form for portability).\n+        library_dirs : [list of strings]\n+            A list of directories to search for C/C++ libraries at link time.\n+        libraries : [list of strings]\n+            A list of library names (not filenames or paths) to link against.\n+        extra_compile_args : [list of strings]\n+            Any extra platform- and compiler-specific information to use when\n+            compiling the source files in 'sources'.  For platforms and\n+            compilers where \"command line\" makes sense, this is typically a\n+            list of command-line arguments, but for other platforms it could be\n+            anything. Note that the attribute ``std_compile_flag`` will be\n+            appended to this list.\n+        extra_link_args : [list of strings]\n+            Any extra platform- and compiler-specific information to use when\n+            linking object files together to create the extension (or to create\n+            a new static Python interpreter). Similar interpretation as for\n+            'extra_compile_args'.\n+        cythonize_options : [dictionary]\n+            Keyword arguments passed on to cythonize.\n+        array_args : [list of strings]\n+            Names of arguments that should be treated as arrays even if they\n+            don't appear in the expression.\n+        \"\"\"=======\n         include_dirs : [list of strings]\n             A list of directories to search for C/C++ header files (in Unix\n             form for portability).\n@@ -977,7 +1028,13 @@ def _partition_args(self, args):\n             elif isinstance(arg, InOutArgument):\n                 raise ValueError(\"Ufuncify doesn't support InOutArguments\")\n             else:\n-                py_in.append(arg)\n+                # Always treat array arguments as input arrays, even if unused\n+                if arg.dimensions:\n+                    py_in.append(arg)\n+                elif arg.name in self._settings.get('array_args', []):\n+                    py_in.append(arg)\n+                else:\n+                    py_in.append(arg)\n         return py_in, py_out\n \n \n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": true,
    "resolved": false
}