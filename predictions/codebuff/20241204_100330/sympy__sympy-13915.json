{
    "instance_id": "sympy__sympy-13915",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex d4ca323e0d..0708f0cfa1 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -923,6 +923,103 @@ def subs(self, *args, **kwargs):\n             return rv\n \n     @cacheit\n+\n+        Add's _eval_subs knows how to target x + y in the following\n+        so it makes the change:\n+\n+            >>> (x + y + z).subs(x + y, 1)\n+            z + 1\n+\n+        Add's _eval_subs doesn't need to know how to find x + y in\n+        the following:\n+\n+            >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None\n+            True\n+\n+        The returned None will cause the fallback routine to traverse the args and\n+        pass the z*(x + y) arg to Mul where the change will take place and the\n+        substitution will succeed:\n+\n+            >>> (z*(x + y) + 3).subs(x + y, 1)\n+            z + 3\n+\n+        ** Developers Notes **\n+\n+        An _eval_subs routine for a class should be written if:\n+\n+            1) any arguments are not instances of Basic (e.g. bool, tuple);\n+\n+            2) some arguments should not be targeted (as in integration\n+               variables);\n+\n+            3) if there is something other than a literal replacement\n+               that should be attempted (as in Piecewise where the condition\n+               may be updated without doing a replacement).\n+\n+        If it is overridden, here are some special cases that might arise:\n+\n+            1) If it turns out that no special change was made and all\n+               the original sub-arguments should be checked for\n+               replacements then None should be returned.\n+\n+            2) If it is necessary to do substitutions on a portion of\n+               the expression then _subs should be called. _subs will\n+               handle the case of any sub-expression being equal to old\n+               (which usually would not be the case) while its fallback\n+               will handle the recursion into the sub-arguments. For\n+               example, after Add's _eval_subs removes some matching terms\n+               it must process the remaining terms so it calls _subs\n+               on each of the un-matched terms and then adds them\n+               onto the terms previously obtained.\n+\n+           3) If the initial expression should remain unchanged then\n+              the original expression should be returned. (Whenever an\n+              expression is returned, modified or not, no further\n+              substitution of old -> new is attempted.) Sum's _eval_subs\n+              routine uses this strategy when a substitution is attempted\n+              on any of its summation variables.\n+        \"\"\"\n+\n+        def fallback(self, old, new):\n+            \"\"\"\n+            Try to replace old with new in any of self's arguments.\n+            Check for undefined subexpressions during substitution.\n+            \"\"\"\n+            hit = False\n+            args = list(self.args)\n+            for i, arg in enumerate(args):\n+                if not hasattr(arg, '_eval_subs'):\n+                    continue\n+                arg = arg._subs(old, new, **hints)\n+                if not _aresame(arg, args[i]):\n+                    hit = True\n+                    args[i] = arg\n+            if hit:\n+                rv = self.func(*args)\n+                hack2 = hints.get('hack2', False)\n+                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n+                    coeff = S.One\n+                    nonnumber = []\n+                    for i in args:\n+                        if i.is_Number:\n+                            coeff *= i\n+                        else:\n+                            nonnumber.append(i)\n+                    nonnumber = self.func(*nonnumber)\n+                    if coeff is S.One:\n+                        return nonnumber\n+                    else:\n+                        return self.func(coeff, nonnumber, evaluate=False)\n+                \n+                # Check if any subexpressions are undefined after substitution\n+                if any(arg.is_zero for arg in rv.args):\n+                    for arg in rv.args:\n+                        if hasattr(arg, 'is_zero') and arg.is_zero:\n+                            if any(1/t in arg.free_symbols for t in rv.free_symbols):\n+                                return self\n+                return rv\n+            return self\n+=======\n     def _subs(self, old, new, **hints):\n         \"\"\"Substitutes an expression old -> new.\n \n@@ -994,6 +1091,102 @@ def _subs(self, old, new, **hints):\n               on any of its summation variables.\n         \"\"\"\n \n+        def fallback(self, old, new):\n+            \"\"\"\n+            Try to replace old with new in any of self's arguments.\n+            Check for undefined subexpressions during substitution.\n+            \"\"\"\n+            hit = False\n+            args = list(self.args)\n+            for i, arg in enumerate(args):\n+                if not hasattr(arg, '_eval_subs'):\n+                    continue\n+                arg = arg._subs(old, new, **hints)\n+                if not _aresame(arg, args[i]):\n+                    hit = True\n+                    args[i] = arg\n+            if hit:\n+                rv = self.func(*args)\n+                hack2 = hints.get('hack2', False)\n+                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n+                    coeff = S.One\n+                    nonnumber = []\n+                    for i in args:\n+                        if i.is_Number:\n+                            coeff *= i\n+                        else:\n+                            nonnumber.append(i)\n+                    nonnumber = self.func(*nonnumber)\n+                    if coeff is S.One:\n+                        return nonnumber\n+                    else:\n+                        return self.func(coeff, nonnumber, evaluate=False)\n+                \n+                # Check if any subexpressions are undefined after substitution\n+                if any(arg.is_zero for arg in rv.args):\n+                    for arg in rv.args:\n+                        if hasattr(arg, 'is_zero') and arg.is_zero:\n+                            if any(1/t in arg.free_symbols for t in rv.free_symbols):\n+                                return self\n+                return rv\n+            return self=======\n+\n+        Add's _eval_subs knows how to target x + y in the following\n+        so it makes the change:\n+\n+            >>> (x + y + z).subs(x + y, 1)\n+            z + 1\n+\n+        Add's _eval_subs doesn't need to know how to find x + y in\n+        the following:\n+\n+            >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None\n+            True\n+\n+        The returned None will cause the fallback routine to traverse the args and\n+        pass the z*(x + y) arg to Mul where the change will take place and the\n+        substitution will succeed:\n+\n+            >>> (z*(x + y) + 3).subs(x + y, 1)\n+            z + 3\n+\n+        ** Developers Notes **\n+\n+        An _eval_subs routine for a class should be written if:\n+\n+            1) any arguments are not instances of Basic (e.g. bool, tuple);\n+\n+            2) some arguments should not be targeted (as in integration\n+               variables);\n+\n+            3) if there is something other than a literal replacement\n+               that should be attempted (as in Piecewise where the condition\n+               may be updated without doing a replacement).\n+\n+        If it is overridden, here are some special cases that might arise:\n+\n+            1) If it turns out that no special change was made and all\n+               the original sub-arguments should be checked for\n+               replacements then None should be returned.\n+\n+            2) If it is necessary to do substitutions on a portion of\n+               the expression then _subs should be called. _subs will\n+               handle the case of any sub-expression being equal to old\n+               (which usually would not be the case) while its fallback\n+               will handle the recursion into the sub-arguments. For\n+               example, after Add's _eval_subs removes some matching terms\n+               it must process the remaining terms so it calls _subs\n+               on each of the un-matched terms and then adds them\n+               onto the terms previously obtained.\n+\n+           3) If the initial expression should remain unchanged then\n+              the original expression should be returned. (Whenever an\n+              expression is returned, modified or not, no further\n+              substitution of old -> new is attempted.) Sum's _eval_subs\n+              routine uses this strategy when a substitution is attempted\n+              on any of its summation variables.\n+        \"\"\"\n+\n         def fallback(self, old, new):\n             \"\"\"\n             Try to replace old with new in any of self's arguments.\n@@ -1027,6 +1220,10 @@ def fallback(self, old, new):\n             return self\n \n         if _aresame(self, old):\n+            # Check if substitution would create undefined expression\n+            if hasattr(new, 'is_zero') and new.is_zero:\n+                if any(1/t in self.free_symbols for t in old.free_symbols):\n+                    return self\n             return new\n \n         rv = self._eval_subs(old, new)\ndiff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 04cf2c391a..db065d260b 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -105,6 +105,12 @@ def test_subs():\n \n     assert b21.subs([(b2, b1), (b1, b2)]) == Basic(b2, b2)\n \n+    # Test undefined substitutions\n+    from sympy import symbols, S\n+    a, b = symbols('a b')\n+    r = (1/(a+b) + 1/(a-b))/(1/(a+b) - 1/(a-b))\n+    assert r.subs(b, a) == r  # Should preserve original expression when undefined\n+\n     assert b21.subs({b1: b2, b2: b1}) == Basic(b2, b2)\n     if sys.version_info >= (3, 4):\n         assert b21.subs(collections.ChainMap({b1: b2}, {b2: b1})) == Basic(b2, b2)\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}