{
    "instance_id": "sympy__sympy-18532",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 6866648d4e..e418cf7e23 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -431,13 +431,81 @@ def _repr_latex_(self):\n \n     _repr_latex_orig = _repr_latex_\n \n+\n+        >>> from sympy import I, pi, sin\n+        >>> from sympy.abc import x, y\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms()\n+        {1, 2, I, pi, x, y}\n+\n+        If one or more types are given, the results will contain only\n+        those types of atoms.\n+\n+        >>> from sympy import Number, NumberSymbol, Symbol\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n+        {x, y}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n+        {1, 2}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n+        {1, 2, pi}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n+        {1, 2, I, pi}\n+\n+        Note that I (imaginary unit) and zoo (complex infinity) are special\n+        types of number symbols and are not part of the NumberSymbol class.\n+\n+        The type can be given implicitly, too:\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n+        {x, y}\n+\n+        Be careful to check your assumptions when using the implicit option\n+        since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n+        of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n+        integers in an expression:\n+\n+        >>> from sympy import S\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n+        {1}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n+        {1, 2}\n+\n+        Finally, arguments to atoms() can select more than atomic atoms: any\n+        sympy type (loaded in core/__init__.py) can be listed as an argument\n+        and those types of \"atoms\" as found in scanning the arguments of the\n+        expression recursively:\n+\n+        >>> from sympy import Function, Mul\n+        >>> from sympy.core.function import AppliedUndef\n+        >>> f = Function('f')\n+        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n+        {f(x), sin(y + I*pi)}\n+        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n+        {f(x)}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n+        {I*pi, 2*sin(y + I*pi)}\n+\n+        \"\"\"\n+        if types:\n+            types = tuple(\n+                [t if isinstance(t, type) else type(t) for t in types])\n+        else:\n+            types = (Atom,)\n+        result = set()\n+        for expr in preorder_traversal(self):\n+            if isinstance(expr, types):\n+                result.add(expr)\n+        return result\n+=======\n     def atoms(self, *types):\n         \"\"\"Returns the atoms that form the current object.\n \n-        By default, only objects that are truly atomic and can't\n-        be divided into smaller pieces are returned: symbols, numbers,\n-        and number symbols like I and pi. It is possible to request\n-        atoms of any type, however, as demonstrated below.\n+        By default, only objects that have no args (true leaf nodes) are returned.\n+        It is possible to request atoms of any type, however, as demonstrated below.\n \n         Examples\n         ========\n@@ -499,6 +567,79 @@ def atoms(self, *types):\n         >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n         {I*pi, 2*sin(y + I*pi)}\n \n+        \"\"\"\n+        if types:\n+            types = tuple(\n+                [t if isinstance(t, type) else type(t) for t in types])\n+            result = set()\n+            for expr in preorder_traversal(self):\n+                if isinstance(expr, types):\n+                    result.add(expr)\n+            return result\n+        else:\n+            result = set()\n+            for expr in preorder_traversal(self):\n+                if not expr.args:\n+                    result.add(expr)\n+            return result=======\n+\n+        >>> from sympy import I, pi, sin\n+        >>> from sympy.abc import x, y\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms()\n+        {1, 2, I, pi, x, y}\n+\n+        If one or more types are given, the results will contain only\n+        those types of atoms.\n+\n+        >>> from sympy import Number, NumberSymbol, Symbol\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n+        {x, y}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n+        {1, 2}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n+        {1, 2, pi}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n+        {1, 2, I, pi}\n+\n+        Note that I (imaginary unit) and zoo (complex infinity) are special\n+        types of number symbols and are not part of the NumberSymbol class.\n+\n+        The type can be given implicitly, too:\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n+        {x, y}\n+\n+        Be careful to check your assumptions when using the implicit option\n+        since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n+        of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n+        integers in an expression:\n+\n+        >>> from sympy import S\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n+        {1}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n+        {1, 2}\n+\n+        Finally, arguments to atoms() can select more than atomic atoms: any\n+        sympy type (loaded in core/__init__.py) can be listed as an argument\n+        and those types of \"atoms\" as found in scanning the arguments of the\n+        expression recursively:\n+\n+        >>> from sympy import Function, Mul\n+        >>> from sympy.core.function import AppliedUndef\n+        >>> f = Function('f')\n+        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n+        {f(x), sin(y + I*pi)}\n+        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n+        {f(x)}\n+\n+        >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n+        {I*pi, 2*sin(y + I*pi)}\n+\n         \"\"\"\n         if types:\n             types = tuple(\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}