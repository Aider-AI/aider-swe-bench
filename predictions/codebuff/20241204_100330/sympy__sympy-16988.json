{
    "instance_id": "sympy__sympy-16988",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 03cf57a30b..f2fb75be7f 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -1262,6 +1262,9 @@ def __new__(cls, *args, **kwargs):\n         # flatten inputs to merge intersections and iterables\n         args = _sympify(args)\n \n+        # Remove duplicates while preserving order\n+        args = list(dict.fromkeys(args))\n+\n         # Reduce sets using known rules\n         if evaluate:\n             args = list(cls._new_args_filter(args))\n@@ -1314,8 +1317,10 @@ def __iter__(self):\n \n     @staticmethod\n     def _handle_finite_sets(args):\n-        from sympy.core.logic import fuzzy_and, fuzzy_bool\n+        from sympy.core.logic import fuzzy_and, fuzzy_bool, And\n         from sympy.core.compatibility import zip_longest\n+        from sympy.core.relational import Eq\n+        from sympy.functions.elementary.piecewise import Piecewise\n \n         fs_args, other = sift(args, lambda x: x.is_FiniteSet,\n             binary=True)\n@@ -1340,43 +1345,49 @@ def _handle_finite_sets(args):\n         res = FiniteSet(\n             *res, evaluate=False) if res else S.EmptySet\n         if unk:\n-            symbolic_s_list = [x for x in s if x.has(Symbol)]\n-            non_symbolic_s = s - FiniteSet(\n-                *symbolic_s_list, evaluate=False)\n-            while fs_args:\n-                v = fs_args.pop()\n-                if all(i == j for i, j in zip_longest(\n-                        symbolic_s_list,\n-                        (x for x in v if x.has(Symbol)))):\n-                    # all the symbolic elements of `v` are the same\n-                    # as in `s` so remove the non-symbol containing\n-                    # expressions from `unk`, since they cannot be\n-                    # contained\n-                    for x in non_symbolic_s:\n-                        if x in unk:\n-                            unk.remove(x)\n-                else:\n-                    # if only a subset of elements in `s` are\n-                    # contained in `v` then remove them from `v`\n-                    # and add this as a new arg\n-                    contained = [x for x in symbolic_s_list\n-                        if sympify(v.contains(x)) is S.true]\n-                    if contained != symbolic_s_list:\n-                        other.append(\n-                            v - FiniteSet(\n-                            *contained, evaluate=False))\n-                    else:\n-                        pass  # for coverage\n-\n-            other_sets = Intersection(*other)\n-            if not other_sets:\n-                return S.EmptySet  # b/c we use evaluate=False below\n-            elif other_sets == S.UniversalSet:\n-                res += FiniteSet(*unk)\n+            if len(res) == 1 and len(unk) == 0 and len(other) == 1:\n+                # Special case for Intersection({1}, {x}) type patterns\n+                val = res[0]\n+                cond = Eq(list(other)[0].args[0], val)\n+                return Piecewise((FiniteSet(val), cond), (S.EmptySet, True))\n             else:\n-                res += Intersection(\n-                    FiniteSet(*unk),\n-                    other_sets, evaluate=False)\n+                symbolic_s_list = [x for x in s if x.has(Symbol)]\n+                non_symbolic_s = s - FiniteSet(\n+                    *symbolic_s_list, evaluate=False)\n+                while fs_args:\n+                    v = fs_args.pop()\n+                    if all(i == j for i, j in zip_longest(\n+                            symbolic_s_list,\n+                            (x for x in v if x.has(Symbol)))):\n+                        # all the symbolic elements of `v` are the same\n+                        # as in `s` so remove the non-symbol containing\n+                        # expressions from `unk`, since they cannot be\n+                        # contained\n+                        for x in non_symbolic_s:\n+                            if x in unk:\n+                                unk.remove(x)\n+                    else:\n+                        # if only a subset of elements in `s` are\n+                        # contained in `v` then remove them from `v`\n+                        # and add this as a new arg\n+                        contained = [x for x in symbolic_s_list\n+                            if sympify(v.contains(x)) is S.true]\n+                        if contained != symbolic_s_list:\n+                            other.append(\n+                                v - FiniteSet(\n+                                *contained, evaluate=False))\n+                        else:\n+                            pass  # for coverage\n+\n+                other_sets = Intersection(*other)\n+                if not other_sets:\n+                    return S.EmptySet  # b/c we use evaluate=False below\n+                elif other_sets == S.UniversalSet:\n+                    res += FiniteSet(*unk)\n+                else:\n+                    res += Intersection(\n+                        FiniteSet(*unk),\n+                        other_sets, evaluate=False)\n         return res\n \n     def as_relational(self, symbol):\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}