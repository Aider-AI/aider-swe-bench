{
    "instance_id": "sympy__sympy-11870",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\nindex b2a3f3d6a7..19d987bc80 100644\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -1737,6 +1737,41 @@ def taylor_term(n, x, *previous_terms):\n                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))\n \n \n+\n+    >>> from sympy import sinc, oo, jn, Product, Symbol\n+    >>> from sympy.abc import x\n+    >>> sinc(x)\n+    sinc(x)\n+\n+    * Automated Evaluation\n+\n+    >>> sinc(0)\n+    1\n+    >>> sinc(oo)\n+    0\n+\n+    * Differentiation\n+\n+    >>> sinc(x).diff()\n+    (x*cos(x) - sin(x))/x**2\n+\n+    * Series Expansion\n+\n+    >>> sinc(x).series()\n+    1 - x**2/6 + x**4/120 + O(x**6)\n+\n+    * As zero'th order spherical Bessel Function\n+\n+    >>> sinc(x).rewrite(jn)\n+    jn(0, x)\n+\n+    References\n+    ==========\n+\n+    .. [1] http://en.wikipedia.org/wiki/Sinc_function\n+\n+    \"\"\"\n+=======\n class sinc(TrigonometricFunction):\n     r\"\"\"Represents unnormalized sinc function\n \n@@ -1770,6 +1805,46 @@ class sinc(TrigonometricFunction):\n     >>> sinc(x).rewrite(jn)\n     jn(0, x)\n \n+    * From exponential form\n+\n+    >>> from sympy import exp, I\n+    >>> sinc(x).rewrite(exp)\n+    (-I*exp(I*x) + I*exp(-I*x))/(2*x)\n+\n+    References\n+    ==========\n+\n+    .. [1] http://en.wikipedia.org/wiki/Sinc_function\n+\n+    \"\"\"=======\n+\n+    >>> from sympy import sinc, oo, jn, Product, Symbol\n+    >>> from sympy.abc import x\n+    >>> sinc(x)\n+    sinc(x)\n+\n+    * Automated Evaluation\n+\n+    >>> sinc(0)\n+    1\n+    >>> sinc(oo)\n+    0\n+\n+    * Differentiation\n+\n+    >>> sinc(x).diff()\n+    (x*cos(x) - sin(x))/x**2\n+\n+    * Series Expansion\n+\n+    >>> sinc(x).series()\n+    1 - x**2/6 + x**4/120 + O(x**6)\n+\n+    * As zero'th order spherical Bessel Function\n+\n+    >>> sinc(x).rewrite(jn)\n+    jn(0, x)\n+\n     References\n     ==========\n \n@@ -1819,6 +1894,10 @@ def _eval_rewrite_as_jn(self, arg):\n     def _eval_rewrite_as_sin(self, arg):\n         return sin(arg) / arg\n \n+    def _eval_rewrite_as_exp(self, arg):\n+        from sympy import exp, I\n+        return (-I*exp(I*arg) + I*exp(-I*arg))/(2*arg)\n+\n \n ###############################################################################\n ########################### TRIGONOMETRIC INVERSES ############################\ndiff --git a/sympy/integrals/tests/test_trigonometry.py b/sympy/integrals/tests/test_trigonometry.py\nindex b7eab377c2..dc041aee16 100644\n--- a/sympy/integrals/tests/test_trigonometry.py\n+++ b/sympy/integrals/tests/test_trigonometry.py\n@@ -1,10 +1,16 @@\n-from sympy.core import Eq, Rational, Symbol\n-from sympy.functions import sin, cos, tan, csc, sec, cot, log, Piecewise\n+from sympy.core import Eq, Rational, Symbol, I, S\n+from sympy.functions import sin, cos, tan, csc, sec, cot, log, Piecewise, exp, sinc\n+from sympy.simplify.trigsimp import trigsimp\n from sympy.integrals.trigonometry import trigintegrate\n \n x = Symbol('x')\n \n \n+def test_exp_trig_conversion():\n+    k = Symbol('k')\n+    assert trigsimp(S.Half * (-I*exp(I*k) + I*exp(-I*k))) == sin(k)\n+    assert trigsimp(S.Half/k * (-I*exp(I*k) + I*exp(-I*k))) == sinc(k)\n+\n def test_trigintegrate_odd():\n     assert trigintegrate(Rational(1), x) == x\n     assert trigintegrate(x, x) is None\ndiff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..5e7444f6a6 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -752,10 +752,20 @@ def _trigpats():\n     global _trigpat\n     a, b, c = symbols('a b c', cls=Wild)\n     d = Wild('d', commutative=False)\n+    I = S.ImaginaryUnit\n+\n+    # Add pattern for exponential to trig conversion\n+    exp_trig = (\n+        (S.Half * (-I*exp(I*b) + I*exp(-I*b)), sin(b)),\n+    )\n \n     # for the simplifications like sinh/cosh -> tanh:\n     # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n     # order in _match_div_rewrite.\n+    exp_trig_div = (\n+        (S.Half/b * (-I*exp(I*b) + I*exp(-I*b)), sin(b)/b),\n+    )\n+\n     matchers_division = (\n         (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n         (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n@@ -828,7 +838,7 @@ def _trigpats():\n     )\n \n     _trigpat = (a, b, c, d, matchers_division, matchers_add,\n-        matchers_identity, artifacts)\n+        matchers_identity, artifacts, exp_trig, exp_trig_div)\n     return _trigpat\n \n \n@@ -1113,6 +1123,7 @@ def _futrig(e, **kwargs):\n         TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n         TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n         TR12)\n+    from sympy.core.numbers import I\n     from sympy.core.compatibility import _nodes\n \n     if not e.has(TrigonometricFunction):\n@@ -1126,6 +1137,14 @@ def _futrig(e, **kwargs):\n     Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n     trigs = lambda x: x.has(TrigonometricFunction)\n \n+    # First try exponential patterns\n+    if e.has(exp):\n+        exp_trig, exp_trig_div = _trigpat[-2:]\n+        for pattern, result in exp_trig + exp_trig_div:\n+            res = e.match(pattern)\n+            if res is not None:\n+                return result.subs(res)\n+\n     tree = [identity,\n         (\n         TR3,  # canonical angles\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}