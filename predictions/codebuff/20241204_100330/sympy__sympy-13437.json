{
    "instance_id": "sympy__sympy-13437",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/functions/combinatorial/numbers.py b/sympy/functions/combinatorial/numbers.py\nindex 896729ac87..4e6612c173 100644\n--- a/sympy/functions/combinatorial/numbers.py\n+++ b/sympy/functions/combinatorial/numbers.py\n@@ -369,6 +369,8 @@ class bell(Function):\n     t**4 + 6*t**3 + 7*t**2 + t\n     >>> bell(6, 2, symbols('x:6')[1:])\n     6*x1*x5 + 15*x2*x4 + 10*x3**2\n+    >>> bell(S.Infinity)\n+    oo\n \n     References\n     ==========\n@@ -433,14 +435,18 @@ def _bell_incomplete_poly(n, k, symbols):\n         return expand_mul(s)\n \n     @classmethod\n-    def eval(cls, n, k_sym=None, symbols=None):\n+    def eval(cls, n, k=None, symbols=None):\n+        if n is S.Infinity:\n+            if k is None:\n+                return S.Infinity\n+            return None\n         if n.is_Integer and n.is_nonnegative:\n-            if k_sym is None:\n+            if k is None:\n                 return Integer(cls._bell(int(n)))\n             elif symbols is None:\n-                return cls._bell_poly(int(n)).subs(_sym, k_sym)\n+                return cls._bell_poly(int(n)).subs(_sym, k)\n             else:\n-                r = cls._bell_incomplete_poly(int(n), int(k_sym), symbols)\n+                r = cls._bell_incomplete_poly(int(n), int(k), symbols)\n                 return r\n \n     def _eval_rewrite_as_Sum(self, n, k_sym=None, symbols=None):\n@@ -846,7 +852,6 @@ def _eval_evalf(self, prec):\n #                                                                            #\n #----------------------------------------------------------------------------#\n \n-\n class catalan(Function):\n     r\"\"\"\n     Catalan numbers\n@@ -925,7 +930,6 @@ class catalan(Function):\n     ========\n \n     bell, bernoulli, euler, fibonacci, harmonic, lucas\n-    sympy.functions.combinatorial.factorials.binomial\n     \"\"\"\n \n     @classmethod\n@@ -933,7 +937,7 @@ def eval(cls, n):\n         from sympy import gamma\n         if (n.is_Integer and n.is_nonnegative) or \\\n            (n.is_noninteger and n.is_negative):\n-            return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))\n+            return 4**n*gamma(n + S.Half)/(sqrt(pi)*gamma(n + 2))\n \n         if (n.is_integer and n.is_negative):\n             if (n + 1).is_negative:\n@@ -1338,8 +1342,8 @@ def nC(n, k=None, replacement=False):\n     then the total of all combinations of length 0 hrough ``k`` is the\n     product, ``(m_1 + 1)*(m_2 + 1)*...*(m_k + 1)``. When the multiplicity\n     of each item is 1 (i.e., k unique items) then there are 2**k\n-    combinations. For example, if there are 4 unique items, the total number\n-    of combinations is 16:\n+    combinations. For example, if there are 4 unique items, the total\n+    number of combinations is 16:\n \n     >>> sum(nC(4, i) for i in range(5))\n     16\n@@ -1438,11 +1442,6 @@ def stirling(n, k, d=None, kind=2, signed=False):\n     { } = 1;  { } = { } = 0; {     } = j*{ } + {     }\n     {0}       {0}   {k}      {  k  }     {k}   {k - 1}\n \n-    where ``j`` is::\n-        ``n`` for Stirling numbers of the first kind\n-        ``-n`` for signed Stirling numbers of the first kind\n-        ``k`` for Stirling numbers of the second kind\n-\n     The first kind of Stirling number counts the number of permutations of\n     ``n`` distinct items that have ``k`` cycles; the second kind counts the\n     ways in which ``n`` distinct items can be partitioned into ``k`` parts.\n@@ -1602,8 +1601,6 @@ def nT(n, k=None):\n     sympy.utilities.iterables.multiset_partitions\n \n     \"\"\"\n-    from sympy.utilities.enumerative import MultisetPartitionTraverser\n-\n     if isinstance(n, SYMPY_INTS):\n         # assert n >= 0\n         # all the same\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}