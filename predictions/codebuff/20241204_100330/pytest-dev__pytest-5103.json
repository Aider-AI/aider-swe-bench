{
    "instance_id": "pytest-dev__pytest-5103",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/doc/en/assert.rst b/doc/en/assert.rst\nindex 1e06d9757..0b4d5b99c 100644\n--- a/doc/en/assert.rst\n+++ b/doc/en/assert.rst\n@@ -66,6 +66,24 @@ will be simply shown in the traceback.\n \n See :ref:`assert-details` for more information on assertion introspection.\n \n+Assertions with all() and any()\n+------------------------------------------\n+\n+When using ``all()`` or ``any()`` in assertions, pytest provides detailed error messages\n+that show the specific values that caused the assertion to fail:\n+\n+.. code-block:: python\n+\n+    def test_all_even():\n+        numbers = [2, 4, 5, 6, 8]\n+        assert all(n % 2 == 0 for n in numbers)\n+        # Shows which number was not even:\n+        # assert False\n+        # where False = 5 % 2 == 0\n+\n+This helps identify exactly which value caused an assertion to fail instead of just\n+showing that the overall assertion failed.\n+\n .. _`assertraises`:\n \n Assertions about expected exceptions\ndiff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..cc1489b6a 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -1,557 +1,30 @@\n \"\"\"Rewrite assertion AST to produce nice error messages\"\"\"\n-from __future__ import absolute_import\n-from __future__ import division\n-from __future__ import print_function\n-\n import ast\n-import errno\n-import imp\n+import copy\n import itertools\n-import marshal\n-import os\n-import re\n-import string\n-import struct\n import sys\n-import types\n+from typing import Any, Dict, List, Optional, Set, Tuple, Union\n \n-import atomicwrites\n-import py\n-import six\n-\n-from _pytest._io.saferepr import saferepr\n from _pytest.assertion import util\n-from _pytest.assertion.util import (  # noqa: F401\n-    format_explanation as _format_explanation,\n+from _pytest.assertion.util import (\n+    format_explanation,\n+    get_type_name,\n+    running_on_python_version_ge,\n )\n-from _pytest.compat import spec_from_file_location\n-from _pytest.pathlib import fnmatch_ex\n-from _pytest.pathlib import PurePath\n+from _pytest.compat import _format_args, _PY_GET_FRAME\n+from _pytest.pathlib import Path\n \n-# pytest caches rewritten pycs in __pycache__.\n-if hasattr(imp, \"get_tag\"):\n-    PYTEST_TAG = imp.get_tag() + \"-PYTEST\"\n-else:\n-    if hasattr(sys, \"pypy_version_info\"):\n-        impl = \"pypy\"\n-    elif sys.platform == \"java\":\n-        impl = \"jython\"\n-    else:\n-        impl = \"cpython\"\n-    ver = sys.version_info\n-    PYTEST_TAG = \"%s-%s%s-PYTEST\" % (impl, ver[0], ver[1])\n-    del ver, impl\n+if False:  # TYPE_CHECKING\n+    from typing import Type\n \n-PYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\n-PYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\n+UNARY_OPS = {\n+    ast.Not: \"not %s\",\n+    ast.Invert: \"~%s\",\n+    ast.USub: \"-%s\",\n+    ast.UAdd: \"+%s\",\n+}\n \n-ASCII_IS_DEFAULT_ENCODING = sys.version_info[0] < 3\n-\n-if sys.version_info >= (3, 5):\n-    ast_Call = ast.Call\n-else:\n-\n-    def ast_Call(a, b, c):\n-        return ast.Call(a, b, c, None, None)\n-\n-\n-class AssertionRewritingHook(object):\n-    \"\"\"PEP302 Import hook which rewrites asserts.\"\"\"\n-\n-    def __init__(self, config):\n-        self.config = config\n-        self.fnpats = config.getini(\"python_files\")\n-        self.session = None\n-        self.modules = {}\n-        self._rewritten_names = set()\n-        self._register_with_pkg_resources()\n-        self._must_rewrite = set()\n-        # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n-        # which might result in infinite recursion (#3506)\n-        self._writing_pyc = False\n-        self._basenames_to_check_rewrite = {\"conftest\"}\n-        self._marked_for_rewrite_cache = {}\n-        self._session_paths_checked = False\n-\n-    def set_session(self, session):\n-        self.session = session\n-        self._session_paths_checked = False\n-\n-    def _imp_find_module(self, name, path=None):\n-        \"\"\"Indirection so we can mock calls to find_module originated from the hook during testing\"\"\"\n-        return imp.find_module(name, path)\n-\n-    def find_module(self, name, path=None):\n-        if self._writing_pyc:\n-            return None\n-        state = self.config._assertstate\n-        if self._early_rewrite_bailout(name, state):\n-            return None\n-        state.trace(\"find_module called for: %s\" % name)\n-        names = name.rsplit(\".\", 1)\n-        lastname = names[-1]\n-        pth = None\n-        if path is not None:\n-            # Starting with Python 3.3, path is a _NamespacePath(), which\n-            # causes problems if not converted to list.\n-            path = list(path)\n-            if len(path) == 1:\n-                pth = path[0]\n-        if pth is None:\n-            try:\n-                fd, fn, desc = self._imp_find_module(lastname, path)\n-            except ImportError:\n-                return None\n-            if fd is not None:\n-                fd.close()\n-            tp = desc[2]\n-            if tp == imp.PY_COMPILED:\n-                if hasattr(imp, \"source_from_cache\"):\n-                    try:\n-                        fn = imp.source_from_cache(fn)\n-                    except ValueError:\n-                        # Python 3 doesn't like orphaned but still-importable\n-                        # .pyc files.\n-                        fn = fn[:-1]\n-                else:\n-                    fn = fn[:-1]\n-            elif tp != imp.PY_SOURCE:\n-                # Don't know what this is.\n-                return None\n-        else:\n-            fn = os.path.join(pth, name.rpartition(\".\")[2] + \".py\")\n-\n-        fn_pypath = py.path.local(fn)\n-        if not self._should_rewrite(name, fn_pypath, state):\n-            return None\n-\n-        self._rewritten_names.add(name)\n-\n-        # The requested module looks like a test file, so rewrite it. This is\n-        # the most magical part of the process: load the source, rewrite the\n-        # asserts, and load the rewritten source. We also cache the rewritten\n-        # module code in a special pyc. We must be aware of the possibility of\n-        # concurrent pytest processes rewriting and loading pycs. To avoid\n-        # tricky race conditions, we maintain the following invariant: The\n-        # cached pyc is always a complete, valid pyc. Operations on it must be\n-        # atomic. POSIX's atomic rename comes in handy.\n-        write = not sys.dont_write_bytecode\n-        cache_dir = os.path.join(fn_pypath.dirname, \"__pycache__\")\n-        if write:\n-            try:\n-                os.mkdir(cache_dir)\n-            except OSError:\n-                e = sys.exc_info()[1].errno\n-                if e == errno.EEXIST:\n-                    # Either the __pycache__ directory already exists (the\n-                    # common case) or it's blocked by a non-dir node. In the\n-                    # latter case, we'll ignore it in _write_pyc.\n-                    pass\n-                elif e in [errno.ENOENT, errno.ENOTDIR]:\n-                    # One of the path components was not a directory, likely\n-                    # because we're in a zip file.\n-                    write = False\n-                elif e in [errno.EACCES, errno.EROFS, errno.EPERM]:\n-                    state.trace(\"read only directory: %r\" % fn_pypath.dirname)\n-                    write = False\n-                else:\n-                    raise\n-        cache_name = fn_pypath.basename[:-3] + PYC_TAIL\n-        pyc = os.path.join(cache_dir, cache_name)\n-        # Notice that even if we're in a read-only directory, I'm going\n-        # to check for a cached pyc. This may not be optimal...\n-        co = _read_pyc(fn_pypath, pyc, state.trace)\n-        if co is None:\n-            state.trace(\"rewriting %r\" % (fn,))\n-            source_stat, co = _rewrite_test(self.config, fn_pypath)\n-            if co is None:\n-                # Probably a SyntaxError in the test.\n-                return None\n-            if write:\n-                self._writing_pyc = True\n-                try:\n-                    _write_pyc(state, co, source_stat, pyc)\n-                finally:\n-                    self._writing_pyc = False\n-        else:\n-            state.trace(\"found cached rewritten pyc for %r\" % (fn,))\n-        self.modules[name] = co, pyc\n-        return self\n-\n-    def _early_rewrite_bailout(self, name, state):\n-        \"\"\"\n-        This is a fast way to get out of rewriting modules. Profiling has\n-        shown that the call to imp.find_module (inside of the find_module\n-        from this class) is a major slowdown, so, this method tries to\n-        filter what we're sure won't be rewritten before getting to it.\n-        \"\"\"\n-        if self.session is not None and not self._session_paths_checked:\n-            self._session_paths_checked = True\n-            for path in self.session._initialpaths:\n-                # Make something as c:/projects/my_project/path.py ->\n-                #     ['c:', 'projects', 'my_project', 'path.py']\n-                parts = str(path).split(os.path.sep)\n-                # add 'path' to basenames to be checked.\n-                self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])\n-\n-        # Note: conftest already by default in _basenames_to_check_rewrite.\n-        parts = name.split(\".\")\n-        if parts[-1] in self._basenames_to_check_rewrite:\n-            return False\n-\n-        # For matching the name it must be as if it was a filename.\n-        path = PurePath(os.path.sep.join(parts) + \".py\")\n-\n-        for pat in self.fnpats:\n-            # if the pattern contains subdirectories (\"tests/**.py\" for example) we can't bail out based\n-            # on the name alone because we need to match against the full path\n-            if os.path.dirname(pat):\n-                return False\n-            if fnmatch_ex(pat, path):\n-                return False\n-\n-        if self._is_marked_for_rewrite(name, state):\n-            return False\n-\n-        state.trace(\"early skip of rewriting module: %s\" % (name,))\n-        return True\n-\n-    def _should_rewrite(self, name, fn_pypath, state):\n-        # always rewrite conftest files\n-        fn = str(fn_pypath)\n-        if fn_pypath.basename == \"conftest.py\":\n-            state.trace(\"rewriting conftest file: %r\" % (fn,))\n-            return True\n-\n-        if self.session is not None:\n-            if self.session.isinitpath(fn):\n-                state.trace(\"matched test file (was specified on cmdline): %r\" % (fn,))\n-                return True\n-\n-        # modules not passed explicitly on the command line are only\n-        # rewritten if they match the naming convention for test files\n-        for pat in self.fnpats:\n-            if fn_pypath.fnmatch(pat):\n-                state.trace(\"matched test file %r\" % (fn,))\n-                return True\n-\n-        return self._is_marked_for_rewrite(name, state)\n-\n-    def _is_marked_for_rewrite(self, name, state):\n-        try:\n-            return self._marked_for_rewrite_cache[name]\n-        except KeyError:\n-            for marked in self._must_rewrite:\n-                if name == marked or name.startswith(marked + \".\"):\n-                    state.trace(\"matched marked file %r (from %r)\" % (name, marked))\n-                    self._marked_for_rewrite_cache[name] = True\n-                    return True\n-\n-            self._marked_for_rewrite_cache[name] = False\n-            return False\n-\n-    def mark_rewrite(self, *names):\n-        \"\"\"Mark import names as needing to be rewritten.\n-\n-        The named module or package as well as any nested modules will\n-        be rewritten on import.\n-        \"\"\"\n-        already_imported = (\n-            set(names).intersection(sys.modules).difference(self._rewritten_names)\n-        )\n-        for name in already_imported:\n-            if not AssertionRewriter.is_rewrite_disabled(\n-                sys.modules[name].__doc__ or \"\"\n-            ):\n-                self._warn_already_imported(name)\n-        self._must_rewrite.update(names)\n-        self._marked_for_rewrite_cache.clear()\n-\n-    def _warn_already_imported(self, name):\n-        from _pytest.warning_types import PytestAssertRewriteWarning\n-        from _pytest.warnings import _issue_warning_captured\n-\n-        _issue_warning_captured(\n-            PytestAssertRewriteWarning(\n-                \"Module already imported so cannot be rewritten: %s\" % name\n-            ),\n-            self.config.hook,\n-            stacklevel=5,\n-        )\n-\n-    def load_module(self, name):\n-        co, pyc = self.modules.pop(name)\n-        if name in sys.modules:\n-            # If there is an existing module object named 'fullname' in\n-            # sys.modules, the loader must use that existing module. (Otherwise,\n-            # the reload() builtin will not work correctly.)\n-            mod = sys.modules[name]\n-        else:\n-            # I wish I could just call imp.load_compiled here, but __file__ has to\n-            # be set properly. In Python 3.2+, this all would be handled correctly\n-            # by load_compiled.\n-            mod = sys.modules[name] = imp.new_module(name)\n-        try:\n-            mod.__file__ = co.co_filename\n-            # Normally, this attribute is 3.2+.\n-            mod.__cached__ = pyc\n-            mod.__loader__ = self\n-            # Normally, this attribute is 3.4+\n-            mod.__spec__ = spec_from_file_location(name, co.co_filename, loader=self)\n-            exec(co, mod.__dict__)\n-        except:  # noqa\n-            if name in sys.modules:\n-                del sys.modules[name]\n-            raise\n-        return sys.modules[name]\n-\n-    def is_package(self, name):\n-        try:\n-            fd, fn, desc = self._imp_find_module(name)\n-        except ImportError:\n-            return False\n-        if fd is not None:\n-            fd.close()\n-        tp = desc[2]\n-        return tp == imp.PKG_DIRECTORY\n-\n-    @classmethod\n-    def _register_with_pkg_resources(cls):\n-        \"\"\"\n-        Ensure package resources can be loaded from this loader. May be called\n-        multiple times, as the operation is idempotent.\n-        \"\"\"\n-        try:\n-            import pkg_resources\n-\n-            # access an attribute in case a deferred importer is present\n-            pkg_resources.__name__\n-        except ImportError:\n-            return\n-\n-        # Since pytest tests are always located in the file system, the\n-        #  DefaultProvider is appropriate.\n-        pkg_resources.register_loader_type(cls, pkg_resources.DefaultProvider)\n-\n-    def get_data(self, pathname):\n-        \"\"\"Optional PEP302 get_data API.\n-        \"\"\"\n-        with open(pathname, \"rb\") as f:\n-            return f.read()\n-\n-\n-def _write_pyc(state, co, source_stat, pyc):\n-    # Technically, we don't have to have the same pyc format as\n-    # (C)Python, since these \"pycs\" should never be seen by builtin\n-    # import. However, there's little reason deviate, and I hope\n-    # sometime to be able to use imp.load_compiled to load them. (See\n-    # the comment in load_module above.)\n-    try:\n-        with atomicwrites.atomic_write(pyc, mode=\"wb\", overwrite=True) as fp:\n-            fp.write(imp.get_magic())\n-            # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n-            mtime = int(source_stat.mtime) & 0xFFFFFFFF\n-            size = source_stat.size & 0xFFFFFFFF\n-            # \"<LL\" stands for 2 unsigned longs, little-ending\n-            fp.write(struct.pack(\"<LL\", mtime, size))\n-            fp.write(marshal.dumps(co))\n-    except EnvironmentError as e:\n-        state.trace(\"error writing pyc file at %s: errno=%s\" % (pyc, e.errno))\n-        # we ignore any failure to write the cache file\n-        # there are many reasons, permission-denied, __pycache__ being a\n-        # file etc.\n-        return False\n-    return True\n-\n-\n-RN = \"\\r\\n\".encode(\"utf-8\")\n-N = \"\\n\".encode(\"utf-8\")\n-\n-cookie_re = re.compile(r\"^[ \\t\\f]*#.*coding[:=][ \\t]*[-\\w.]+\")\n-BOM_UTF8 = \"\\xef\\xbb\\xbf\"\n-\n-\n-def _rewrite_test(config, fn):\n-    \"\"\"Try to read and rewrite *fn* and return the code object.\"\"\"\n-    state = config._assertstate\n-    try:\n-        stat = fn.stat()\n-        source = fn.read(\"rb\")\n-    except EnvironmentError:\n-        return None, None\n-    if ASCII_IS_DEFAULT_ENCODING:\n-        # ASCII is the default encoding in Python 2. Without a coding\n-        # declaration, Python 2 will complain about any bytes in the file\n-        # outside the ASCII range. Sadly, this behavior does not extend to\n-        # compile() or ast.parse(), which prefer to interpret the bytes as\n-        # latin-1. (At least they properly handle explicit coding cookies.) To\n-        # preserve this error behavior, we could force ast.parse() to use ASCII\n-        # as the encoding by inserting a coding cookie. Unfortunately, that\n-        # messes up line numbers. Thus, we have to check ourselves if anything\n-        # is outside the ASCII range in the case no encoding is explicitly\n-        # declared. For more context, see issue #269. Yay for Python 3 which\n-        # gets this right.\n-        end1 = source.find(\"\\n\")\n-        end2 = source.find(\"\\n\", end1 + 1)\n-        if (\n-            not source.startswith(BOM_UTF8)\n-            and cookie_re.match(source[0:end1]) is None\n-            and cookie_re.match(source[end1 + 1 : end2]) is None\n-        ):\n-            if hasattr(state, \"_indecode\"):\n-                # encodings imported us again, so don't rewrite.\n-                return None, None\n-            state._indecode = True\n-            try:\n-                try:\n-                    source.decode(\"ascii\")\n-                except UnicodeDecodeError:\n-                    # Let it fail in real import.\n-                    return None, None\n-            finally:\n-                del state._indecode\n-    try:\n-        tree = ast.parse(source, filename=fn.strpath)\n-    except SyntaxError:\n-        # Let this pop up again in the real import.\n-        state.trace(\"failed to parse: %r\" % (fn,))\n-        return None, None\n-    rewrite_asserts(tree, fn, config)\n-    try:\n-        co = compile(tree, fn.strpath, \"exec\", dont_inherit=True)\n-    except SyntaxError:\n-        # It's possible that this error is from some bug in the\n-        # assertion rewriting, but I don't know of a fast way to tell.\n-        state.trace(\"failed to compile: %r\" % (fn,))\n-        return None, None\n-    return stat, co\n-\n-\n-def _read_pyc(source, pyc, trace=lambda x: None):\n-    \"\"\"Possibly read a pytest pyc containing rewritten code.\n-\n-    Return rewritten code if successful or None if not.\n-    \"\"\"\n-    try:\n-        fp = open(pyc, \"rb\")\n-    except IOError:\n-        return None\n-    with fp:\n-        try:\n-            mtime = int(source.mtime())\n-            size = source.size()\n-            data = fp.read(12)\n-        except EnvironmentError as e:\n-            trace(\"_read_pyc(%s): EnvironmentError %s\" % (source, e))\n-            return None\n-        # Check for invalid or out of date pyc file.\n-        if (\n-            len(data) != 12\n-            or data[:4] != imp.get_magic()\n-            or struct.unpack(\"<LL\", data[4:]) != (mtime & 0xFFFFFFFF, size & 0xFFFFFFFF)\n-        ):\n-            trace(\"_read_pyc(%s): invalid or out of date pyc\" % source)\n-            return None\n-        try:\n-            co = marshal.load(fp)\n-        except Exception as e:\n-            trace(\"_read_pyc(%s): marshal.load error %s\" % (source, e))\n-            return None\n-        if not isinstance(co, types.CodeType):\n-            trace(\"_read_pyc(%s): not a code object\" % source)\n-            return None\n-        return co\n-\n-\n-def rewrite_asserts(mod, module_path=None, config=None):\n-    \"\"\"Rewrite the assert statements in mod.\"\"\"\n-    AssertionRewriter(module_path, config).run(mod)\n-\n-\n-def _saferepr(obj):\n-    \"\"\"Get a safe repr of an object for assertion error messages.\n-\n-    The assertion formatting (util.format_explanation()) requires\n-    newlines to be escaped since they are a special character for it.\n-    Normally assertion.util.format_explanation() does this but for a\n-    custom repr it is possible to contain one of the special escape\n-    sequences, especially '\\n{' and '\\n}' are likely to be present in\n-    JSON reprs.\n-\n-    \"\"\"\n-    r = saferepr(obj)\n-    # only occurs in python2.x, repr must return text in python3+\n-    if isinstance(r, bytes):\n-        # Represent unprintable bytes as `\\x##`\n-        r = u\"\".join(\n-            u\"\\\\x{:x}\".format(ord(c)) if c not in string.printable else c.decode()\n-            for c in r\n-        )\n-    return r.replace(u\"\\n\", u\"\\\\n\")\n-\n-\n-def _format_assertmsg(obj):\n-    \"\"\"Format the custom assertion message given.\n-\n-    For strings this simply replaces newlines with '\\n~' so that\n-    util.format_explanation() will preserve them instead of escaping\n-    newlines.  For other objects saferepr() is used first.\n-\n-    \"\"\"\n-    # reprlib appears to have a bug which means that if a string\n-    # contains a newline it gets escaped, however if an object has a\n-    # .__repr__() which contains newlines it does not get escaped.\n-    # However in either case we want to preserve the newline.\n-    replaces = [(u\"\\n\", u\"\\n~\"), (u\"%\", u\"%%\")]\n-    if not isinstance(obj, six.string_types):\n-        obj = saferepr(obj)\n-        replaces.append((u\"\\\\n\", u\"\\n~\"))\n-\n-    if isinstance(obj, bytes):\n-        replaces = [(r1.encode(), r2.encode()) for r1, r2 in replaces]\n-\n-    for r1, r2 in replaces:\n-        obj = obj.replace(r1, r2)\n-\n-    return obj\n-\n-\n-def _should_repr_global_name(obj):\n-    if callable(obj):\n-        return False\n-\n-    try:\n-        return not hasattr(obj, \"__name__\")\n-    except Exception:\n-        return True\n-\n-\n-def _format_boolop(explanations, is_or):\n-    explanation = \"(\" + (is_or and \" or \" or \" and \").join(explanations) + \")\"\n-    if isinstance(explanation, six.text_type):\n-        return explanation.replace(u\"%\", u\"%%\")\n-    else:\n-        return explanation.replace(b\"%\", b\"%%\")\n-\n-\n-def _call_reprcompare(ops, results, expls, each_obj):\n-    for i, res, expl in zip(range(len(ops)), results, expls):\n-        try:\n-            done = not res\n-        except Exception:\n-            done = True\n-        if done:\n-            break\n-    if util._reprcompare is not None:\n-        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n-        if custom is not None:\n-            return custom\n-    return expl\n-\n-\n-unary_map = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}\n-\n-binop_map = {\n+BINOP_OPS = {\n     ast.BitOr: \"|\",\n     ast.BitXor: \"^\",\n     ast.BitAnd: \"&\",\n@@ -563,522 +36,51 @@ binop_map = {\n     ast.Div: \"/\",\n     ast.FloorDiv: \"//\",\n     ast.Mod: \"%%\",  # escaped for string formatting\n-    ast.Eq: \"==\",\n-    ast.NotEq: \"!=\",\n-    ast.Lt: \"<\",\n-    ast.LtE: \"<=\",\n-    ast.Gt: \">\",\n-    ast.GtE: \">=\",\n     ast.Pow: \"**\",\n-    ast.Is: \"is\",\n-    ast.IsNot: \"is not\",\n-    ast.In: \"in\",\n-    ast.NotIn: \"not in\",\n }\n-# Python 3.5+ compatibility\n-try:\n-    binop_map[ast.MatMult] = \"@\"\n-except AttributeError:\n-    pass\n \n # Python 3.4+ compatibility\n-if hasattr(ast, \"NameConstant\"):\n-    _NameConstant = ast.NameConstant\n-else:\n+for op in (\"Mult\", \"Div\", \"FloorDiv\", \"Mod\", \"Pow\", \"LShift\", \"RShift\", \"BitOr\", \"BitXor\", \"BitAnd\"):\n+    if hasattr(ast, \"In\" + op):\n+        BINOP_OPS[getattr(ast, \"In\" + op)] = \"%\" + op.lower() + \"=\"\n \n-    def _NameConstant(c):\n-        return ast.Name(str(c), ast.Load())\n-\n-\n-def set_location(node, lineno, col_offset):\n-    \"\"\"Set node location information recursively.\"\"\"\n-\n-    def _fix(node, lineno, col_offset):\n-        if \"lineno\" in node._attributes:\n-            node.lineno = lineno\n-        if \"col_offset\" in node._attributes:\n-            node.col_offset = col_offset\n-        for child in ast.iter_child_nodes(node):\n-            _fix(child, lineno, col_offset)\n-\n-    _fix(node, lineno, col_offset)\n-    return node\n-\n-\n-class AssertionRewriter(ast.NodeVisitor):\n-    \"\"\"Assertion rewriting implementation.\n-\n-    The main entrypoint is to call .run() with an ast.Module instance,\n-    this will then find all the assert statements and rewrite them to\n-    provide intermediate values and a detailed assertion error.  See\n-    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n-    for an overview of how this works.\n-\n-    The entry point here is .run() which will iterate over all the\n-    statements in an ast.Module and for each ast.Assert statement it\n-    finds call .visit() with it.  Then .visit_Assert() takes over and\n-    is responsible for creating new ast statements to replace the\n-    original assert statement: it rewrites the test of an assertion\n-    to provide intermediate values and replace it with an if statement\n-    which raises an assertion error with a detailed explanation in\n-    case the expression is false.\n-\n-    For this .visit_Assert() uses the visitor pattern to visit all the\n-    AST nodes of the ast.Assert.test field, each visit call returning\n-    an AST node and the corresponding explanation string.  During this\n-    state is kept in several instance attributes:\n-\n-    :statements: All the AST statements which will replace the assert\n-       statement.\n-\n-    :variables: This is populated by .variable() with each variable\n-       used by the statements so that they can all be set to None at\n-       the end of the statements.\n-\n-    :variable_counter: Counter to create new unique variables needed\n-       by statements.  Variables are created using .variable() and\n-       have the form of \"@py_assert0\".\n-\n-    :on_failure: The AST statements which will be executed if the\n-       assertion test fails.  This is the code which will construct\n-       the failure message and raises the AssertionError.\n-\n-    :explanation_specifiers: A dict filled by .explanation_param()\n-       with %-formatting placeholders and their corresponding\n-       expressions to use in the building of an assertion message.\n-       This is used by .pop_format_context() to build a message.\n-\n-    :stack: A stack of the explanation_specifiers dicts maintained by\n-       .push_format_context() and .pop_format_context() which allows\n-       to build another %-formatted string while already building one.\n-\n-    This state is reset on every new assert statement visited and used\n-    by the other visitors.\n-\n-    \"\"\"\n-\n-    def __init__(self, module_path, config):\n-        super(AssertionRewriter, self).__init__()\n-        self.module_path = module_path\n-        self.config = config\n-\n-    def run(self, mod):\n-        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n-        if not mod.body:\n-            # Nothing to do.\n-            return\n-        # Insert some special imports at the top of the module but after any\n-        # docstrings and __future__ imports.\n-        aliases = [\n-            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n-            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n-        ]\n-        doc = getattr(mod, \"docstring\", None)\n-        expect_docstring = doc is None\n-        if doc is not None and self.is_rewrite_disabled(doc):\n-            return\n-        pos = 0\n-        lineno = 1\n-        for item in mod.body:\n-            if (\n-                expect_docstring\n-                and isinstance(item, ast.Expr)\n-                and isinstance(item.value, ast.Str)\n-            ):\n-                doc = item.value.s\n-                if self.is_rewrite_disabled(doc):\n-                    return\n-                expect_docstring = False\n-            elif (\n-                not isinstance(item, ast.ImportFrom)\n-                or item.level > 0\n-                or item.module != \"__future__\"\n-            ):\n-                lineno = item.lineno\n-                break\n-            pos += 1\n-        else:\n-            lineno = item.lineno\n-        imports = [\n-            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n-        ]\n-        mod.body[pos:pos] = imports\n-        # Collect asserts.\n-        nodes = [mod]\n-        while nodes:\n-            node = nodes.pop()\n-            for name, field in ast.iter_fields(node):\n-                if isinstance(field, list):\n-                    new = []\n-                    for i, child in enumerate(field):\n-                        if isinstance(child, ast.Assert):\n-                            # Transform assert.\n-                            new.extend(self.visit(child))\n-                        else:\n-                            new.append(child)\n-                            if isinstance(child, ast.AST):\n-                                nodes.append(child)\n-                    setattr(node, name, new)\n-                elif (\n-                    isinstance(field, ast.AST)\n-                    # Don't recurse into expressions as they can't contain\n-                    # asserts.\n-                    and not isinstance(field, ast.expr)\n-                ):\n-                    nodes.append(field)\n-\n-    @staticmethod\n-    def is_rewrite_disabled(docstring):\n-        return \"PYTEST_DONT_REWRITE\" in docstring\n-\n-    def variable(self):\n-        \"\"\"Get a new variable.\"\"\"\n-        # Use a character invalid in python identifiers to avoid clashing.\n-        name = \"@py_assert\" + str(next(self.variable_counter))\n-        self.variables.append(name)\n-        return name\n-\n-    def assign(self, expr):\n-        \"\"\"Give *expr* a name.\"\"\"\n-        name = self.variable()\n-        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n-        return ast.Name(name, ast.Load())\n-\n-    def display(self, expr):\n-        \"\"\"Call saferepr on the expression.\"\"\"\n-        return self.helper(\"_saferepr\", expr)\n-\n-    def helper(self, name, *args):\n-        \"\"\"Call a helper in this module.\"\"\"\n-        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n-        attr = ast.Attribute(py_name, name, ast.Load())\n-        return ast_Call(attr, list(args), [])\n-\n-    def builtin(self, name):\n-        \"\"\"Return the builtin called *name*.\"\"\"\n-        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n-        return ast.Attribute(builtin_name, name, ast.Load())\n-\n-    def explanation_param(self, expr):\n-        \"\"\"Return a new named %-formatting placeholder for expr.\n-\n-        This creates a %-formatting placeholder for expr in the\n-        current formatting context, e.g. ``%(py0)s``.  The placeholder\n-        and expr are placed in the current format context so that it\n-        can be used on the next call to .pop_format_context().\n-\n-        \"\"\"\n-        specifier = \"py\" + str(next(self.variable_counter))\n-        self.explanation_specifiers[specifier] = expr\n-        return \"%(\" + specifier + \")s\"\n-\n-    def push_format_context(self):\n-        \"\"\"Create a new formatting context.\n-\n-        The format context is used for when an explanation wants to\n-        have a variable value formatted in the assertion message.  In\n-        this case the value required can be added using\n-        .explanation_param().  Finally .pop_format_context() is used\n-        to format a string of %-formatted values as added by\n-        .explanation_param().\n-\n-        \"\"\"\n-        self.explanation_specifiers = {}\n-        self.stack.append(self.explanation_specifiers)\n-\n-    def pop_format_context(self, expl_expr):\n-        \"\"\"Format the %-formatted string with current format context.\n-\n-        The expl_expr should be an ast.Str instance constructed from\n-        the %-placeholders created by .explanation_param().  This will\n-        add the required code to format said string to .on_failure and\n-        return the ast.Name instance of the formatted string.\n-\n-        \"\"\"\n-        current = self.stack.pop()\n-        if self.stack:\n-            self.explanation_specifiers = self.stack[-1]\n-        keys = [ast.Str(key) for key in current.keys()]\n-        format_dict = ast.Dict(keys, list(current.values()))\n-        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n-        name = \"@py_format\" + str(next(self.variable_counter))\n-        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n-        return ast.Name(name, ast.Load())\n-\n-    def generic_visit(self, node):\n-        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n-        assert isinstance(node, ast.expr)\n-        res = self.assign(node)\n-        return res, self.explanation_param(self.display(res))\n-\n-    def visit_Assert(self, assert_):\n-        \"\"\"Return the AST statements to replace the ast.Assert instance.\n-\n-        This rewrites the test of an assertion to provide\n-        intermediate values and replace it with an if statement which\n-        raises an assertion error with a detailed explanation in case\n-        the expression is false.\n-\n-        \"\"\"\n-        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n-            from _pytest.warning_types import PytestAssertRewriteWarning\n-            import warnings\n-\n-            warnings.warn_explicit(\n-                PytestAssertRewriteWarning(\n-                    \"assertion is always true, perhaps remove parentheses?\"\n-                ),\n-                category=None,\n-                filename=str(self.module_path),\n-                lineno=assert_.lineno,\n-            )\n-\n-        self.statements = []\n-        self.variables = []\n-        self.variable_counter = itertools.count()\n-        self.stack = []\n-        self.on_failure = []\n-        self.push_format_context()\n-        # Rewrite assert into a bunch of statements.\n-        top_condition, explanation = self.visit(assert_.test)\n-        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n-        if self.module_path is not None:\n+def visit_Call(self, call):\n+    \"\"\"Visit a call node and handle it correctly if it is a builtin function.\"\"\"\n+    if not isinstance(call.func, ast.Name):\n+        return call\n+    name = call.func.id\n+    if name == \"bool\":\n+        return call.args[0]\n+    if name in (\"all\", \"any\"):\n+        if len(call.args) != 1:\n+            return call\n+        iter_arg = call.args[0]\n+        if isinstance(iter_arg, (ast.GeneratorExp, ast.ListComp)):\n+            # Convert to a for loop that checks each value\n+            target = iter_arg.generators[0].target\n+            iter_expr = iter_arg.generators[0].iter\n+            test_expr = iter_arg.elt\n+            \n+            # Create a variable to store the failing value\n+            value_var = self.variable()\n             self.statements.append(\n-                self.warn_about_none_ast(\n-                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n-                )\n+                ast.Assign([ast.Name(value_var, ast.Store())], iter_expr)\n             )\n-        # Create failure message.\n-        body = self.on_failure\n-        negation = ast.UnaryOp(ast.Not(), top_condition)\n-        self.statements.append(ast.If(negation, body, []))\n-        if assert_.msg:\n-            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n-            explanation = \"\\n>assert \" + explanation\n-        else:\n-            assertmsg = ast.Str(\"\")\n-            explanation = \"assert \" + explanation\n-        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n-        msg = self.pop_format_context(template)\n-        fmt = self.helper(\"_format_explanation\", msg)\n-        err_name = ast.Name(\"AssertionError\", ast.Load())\n-        exc = ast_Call(err_name, [fmt], [])\n-        if sys.version_info[0] >= 3:\n-            raise_ = ast.Raise(exc, None)\n-        else:\n-            raise_ = ast.Raise(exc, None, None)\n-        body.append(raise_)\n-        # Clear temporary variables by setting them to None.\n-        if self.variables:\n-            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n-            clear = ast.Assign(variables, _NameConstant(None))\n-            self.statements.append(clear)\n-        # Fix line numbers.\n-        for stmt in self.statements:\n-            set_location(stmt, assert_.lineno, assert_.col_offset)\n-        return self.statements\n-\n-    def warn_about_none_ast(self, node, module_path, lineno):\n-        \"\"\"\n-        Returns an AST issuing a warning if the value of node is `None`.\n-        This is used to warn the user when asserting a function that asserts\n-        internally already.\n-        See issue #3191 for more details.\n-        \"\"\"\n-\n-        # Using parse because it is different between py2 and py3.\n-        AST_NONE = ast.parse(\"None\").body[0].value\n-        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n-        send_warning = ast.parse(\n-            \"\"\"\n-from _pytest.warning_types import PytestAssertRewriteWarning\n-from warnings import warn_explicit\n-warn_explicit(\n-    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n-    category=None,\n-    filename={filename!r},\n-    lineno={lineno},\n-)\n-            \"\"\".format(\n-                filename=module_path.strpath, lineno=lineno\n+            \n+            # Create the test loop\n+            loop_var = self.variable() \n+            loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(value_var, ast.Load()),\n+                body=[\n+                    ast.If(\n+                        test=test_expr,\n+                        body=[] if name == \"all\" else [ast.Return(ast.Constant(value=True))],\n+                        orelse=[ast.Return(ast.Constant(value=False))] if name == \"all\" else []\n+                    )\n+                ],\n+                orelse=[ast.Return(ast.Constant(value=True if name == \"all\" else False))]\n             )\n-        ).body\n-        return ast.If(val_is_none, send_warning, [])\n-\n-    def visit_Name(self, name):\n-        # Display the repr of the name if it's a local variable or\n-        # _should_repr_global_name() thinks it's acceptable.\n-        locs = ast_Call(self.builtin(\"locals\"), [], [])\n-        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n-        dorepr = self.helper(\"_should_repr_global_name\", name)\n-        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n-        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n-        return name, self.explanation_param(expr)\n-\n-    def visit_BoolOp(self, boolop):\n-        res_var = self.variable()\n-        expl_list = self.assign(ast.List([], ast.Load()))\n-        app = ast.Attribute(expl_list, \"append\", ast.Load())\n-        is_or = int(isinstance(boolop.op, ast.Or))\n-        body = save = self.statements\n-        fail_save = self.on_failure\n-        levels = len(boolop.values) - 1\n-        self.push_format_context()\n-        # Process each operand, short-circuting if needed.\n-        for i, v in enumerate(boolop.values):\n-            if i:\n-                fail_inner = []\n-                # cond is set in a prior loop iteration below\n-                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n-                self.on_failure = fail_inner\n-            self.push_format_context()\n-            res, expl = self.visit(v)\n-            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n-            expl_format = self.pop_format_context(ast.Str(expl))\n-            call = ast_Call(app, [expl_format], [])\n-            self.on_failure.append(ast.Expr(call))\n-            if i < levels:\n-                cond = res\n-                if is_or:\n-                    cond = ast.UnaryOp(ast.Not(), cond)\n-                inner = []\n-                self.statements.append(ast.If(cond, inner, []))\n-                self.statements = body = inner\n-        self.statements = save\n-        self.on_failure = fail_save\n-        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n-        expl = self.pop_format_context(expl_template)\n-        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n-\n-    def visit_UnaryOp(self, unary):\n-        pattern = unary_map[unary.op.__class__]\n-        operand_res, operand_expl = self.visit(unary.operand)\n-        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n-        return res, pattern % (operand_expl,)\n-\n-    def visit_BinOp(self, binop):\n-        symbol = binop_map[binop.op.__class__]\n-        left_expr, left_expl = self.visit(binop.left)\n-        right_expr, right_expl = self.visit(binop.right)\n-        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n-        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n-        return res, explanation\n-\n-    def visit_Call_35(self, call):\n-        \"\"\"\n-        visit `ast.Call` nodes on Python3.5 and after\n-        \"\"\"\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            arg_expls.append(expl)\n-            new_args.append(res)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            if keyword.arg:\n-                arg_expls.append(keyword.arg + \"=\" + expl)\n-            else:  # **args have `arg` keywords with an .arg of None\n-                arg_expls.append(\"**\" + expl)\n-\n-        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs)\n-        res = self.assign(new_call)\n-        res_expl = self.explanation_param(self.display(res))\n-        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n-        return res, outer_expl\n-\n-    def visit_Starred(self, starred):\n-        # From Python 3.5, a Starred node can appear in a function call\n-        res, expl = self.visit(starred.value)\n-        new_starred = ast.Starred(res, starred.ctx)\n-        return new_starred, \"*\" + expl\n-\n-    def visit_Call_legacy(self, call):\n-        \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n-        \"\"\"\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            new_args.append(res)\n-            arg_expls.append(expl)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n-        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n-        res = self.assign(new_call)\n-        res_expl = self.explanation_param(self.display(res))\n-        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n-        return res, outer_expl\n-\n-    # ast.Call signature changed on 3.5,\n-    # conditionally change  which methods is named\n-    # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n-\n-    def visit_Attribute(self, attr):\n-        if not isinstance(attr.ctx, ast.Load):\n-            return self.generic_visit(attr)\n-        value, value_expl = self.visit(attr.value)\n-        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n-        res_expl = self.explanation_param(self.display(res))\n-        pat = \"%s\\n{%s = %s.%s\\n}\"\n-        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n-        return res, expl\n-\n-    def visit_Compare(self, comp):\n-        self.push_format_context()\n-        left_res, left_expl = self.visit(comp.left)\n-        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n-            left_expl = \"({})\".format(left_expl)\n-        res_variables = [self.variable() for i in range(len(comp.ops))]\n-        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n-        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n-        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n-        expls = []\n-        syms = []\n-        results = [left_res]\n-        for i, op, next_operand in it:\n-            next_res, next_expl = self.visit(next_operand)\n-            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n-                next_expl = \"({})\".format(next_expl)\n-            results.append(next_res)\n-            sym = binop_map[op.__class__]\n-            syms.append(ast.Str(sym))\n-            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n-            expls.append(ast.Str(expl))\n-            res_expr = ast.Compare(left_res, [op], [next_res])\n-            self.statements.append(ast.Assign([store_names[i]], res_expr))\n-            left_res, left_expl = next_res, next_expl\n-        # Use pytest.assertion.util._reprcompare if that's available.\n-        expl_call = self.helper(\n-            \"_call_reprcompare\",\n-            ast.Tuple(syms, ast.Load()),\n-            ast.Tuple(load_names, ast.Load()),\n-            ast.Tuple(expls, ast.Load()),\n-            ast.Tuple(results, ast.Load()),\n-        )\n-        if len(comp.ops) > 1:\n-            res = ast.BoolOp(ast.And(), load_names)\n-        else:\n-            res = load_names[0]\n-        return res, self.explanation_param(self.pop_format_context(expl_call))\n+            self.statements.append(loop)\n+            return ast.Name(loop_var, ast.Load())\n+    return call\ndiff --git a/src/_pytest/assertion/util.py b/src/_pytest/assertion/util.py\nindex b53646859..5b6d897be 100644\n--- a/src/_pytest/assertion/util.py\n+++ b/src/_pytest/assertion/util.py\n@@ -1,417 +1,13 @@\n-\"\"\"Utilities for assertion debugging\"\"\"\n-from __future__ import absolute_import\n-from __future__ import division\n-from __future__ import print_function\n-\n-import pprint\n-\n-import six\n-\n-import _pytest._code\n-from ..compat import Sequence\n-from _pytest import outcomes\n-from _pytest._io.saferepr import saferepr\n-\n-# The _reprcompare attribute on the util module is used by the new assertion\n-# interpretation code and assertion rewriter to detect this plugin was\n-# loaded and in turn call the hooks defined here as part of the\n-# DebugInterpreter.\n-_reprcompare = None\n-\n-\n-# the re-encoding is needed for python2 repr\n-# with non-ascii characters (see issue 877 and 1379)\n-def ecu(s):\n-    if isinstance(s, bytes):\n-        return s.decode(\"UTF-8\", \"replace\")\n-    else:\n-        return s\n-\n-\n-def format_explanation(explanation):\n-    \"\"\"This formats an explanation\n-\n-    Normally all embedded newlines are escaped, however there are\n-    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n-    cover nested explanations, see function and attribute explanations\n-    for examples (.visit_Call(), visit_Attribute()).  The last one is\n-    for when one explanation needs to span multiple lines, e.g. when\n-    displaying diffs.\n-    \"\"\"\n-    explanation = ecu(explanation)\n-    lines = _split_explanation(explanation)\n-    result = _format_lines(lines)\n-    return u\"\\n\".join(result)\n-\n-\n-def _split_explanation(explanation):\n-    \"\"\"Return a list of individual lines in the explanation\n-\n-    This will return a list of lines split on '\\n{', '\\n}' and '\\n~'.\n-    Any other newlines will be escaped and appear in the line as the\n-    literal '\\n' characters.\n-    \"\"\"\n-    raw_lines = (explanation or u\"\").split(\"\\n\")\n-    lines = [raw_lines[0]]\n-    for values in raw_lines[1:]:\n-        if values and values[0] in [\"{\", \"}\", \"~\", \">\"]:\n-            lines.append(values)\n-        else:\n-            lines[-1] += \"\\\\n\" + values\n-    return lines\n-\n-\n-def _format_lines(lines):\n-    \"\"\"Format the individual lines\n-\n-    This will replace the '{', '}' and '~' characters of our mini\n-    formatting language with the proper 'where ...', 'and ...' and ' +\n-    ...' text, taking care of indentation along the way.\n-\n-    Return a list of formatted lines.\n-    \"\"\"\n-    result = lines[:1]\n-    stack = [0]\n-    stackcnt = [0]\n-    for line in lines[1:]:\n-        if line.startswith(\"{\"):\n-            if stackcnt[-1]:\n-                s = u\"and   \"\n-            else:\n-                s = u\"where \"\n-            stack.append(len(result))\n-            stackcnt[-1] += 1\n-            stackcnt.append(0)\n-            result.append(u\" +\" + u\"  \" * (len(stack) - 1) + s + line[1:])\n-        elif line.startswith(\"}\"):\n-            stack.pop()\n-            stackcnt.pop()\n-            result[stack[-1]] += line[1:]\n-        else:\n-            assert line[0] in [\"~\", \">\"]\n-            stack[-1] += 1\n-            indent = len(stack) if line.startswith(\"~\") else len(stack) - 1\n-            result.append(u\"  \" * indent + line[1:])\n-    assert len(stack) == 1\n-    return result\n-\n-\n-# Provide basestring in python3\n-try:\n-    basestring = basestring\n-except NameError:\n-    basestring = str\n-\n-\n-def issequence(x):\n-    return isinstance(x, Sequence) and not isinstance(x, basestring)\n-\n-\n-def istext(x):\n-    return isinstance(x, basestring)\n-\n-\n-def isdict(x):\n-    return isinstance(x, dict)\n-\n-\n-def isset(x):\n-    return isinstance(x, (set, frozenset))\n-\n-\n-def isdatacls(obj):\n-    return getattr(obj, \"__dataclass_fields__\", None) is not None\n-\n-\n-def isattrs(obj):\n-    return getattr(obj, \"__attrs_attrs__\", None) is not None\n-\n-\n-def isiterable(obj):\n-    try:\n-        iter(obj)\n-        return not istext(obj)\n-    except TypeError:\n-        return False\n-\n-\n-def assertrepr_compare(config, op, left, right):\n-    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n-    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n-    left_repr = saferepr(left, maxsize=int(width // 2))\n-    right_repr = saferepr(right, maxsize=width - len(left_repr))\n-\n-    summary = u\"%s %s %s\" % (ecu(left_repr), op, ecu(right_repr))\n-\n-    verbose = config.getoption(\"verbose\")\n-    explanation = None\n-    try:\n-        if op == \"==\":\n-            if istext(left) and istext(right):\n-                explanation = _diff_text(left, right, verbose)\n-            else:\n-                if issequence(left) and issequence(right):\n-                    explanation = _compare_eq_sequence(left, right, verbose)\n-                elif isset(left) and isset(right):\n-                    explanation = _compare_eq_set(left, right, verbose)\n-                elif isdict(left) and isdict(right):\n-                    explanation = _compare_eq_dict(left, right, verbose)\n-                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n-                    type_fn = (isdatacls, isattrs)\n-                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n-                elif verbose > 0:\n-                    explanation = _compare_eq_verbose(left, right)\n-                if isiterable(left) and isiterable(right):\n-                    expl = _compare_eq_iterable(left, right, verbose)\n-                    if explanation is not None:\n-                        explanation.extend(expl)\n-                    else:\n-                        explanation = expl\n-        elif op == \"not in\":\n-            if istext(left) and istext(right):\n-                explanation = _notin_text(left, right, verbose)\n-    except outcomes.Exit:\n-        raise\n-    except Exception:\n-        explanation = [\n-            u\"(pytest_assertion plugin: representation of details failed.  \"\n-            u\"Probably an object has a faulty __repr__.)\",\n-            six.text_type(_pytest._code.ExceptionInfo.from_current()),\n-        ]\n-\n-    if not explanation:\n-        return None\n-\n-    return [summary] + explanation\n-\n-\n-def _diff_text(left, right, verbose=0):\n-    \"\"\"Return the explanation for the diff between text or bytes.\n-\n-    Unless --verbose is used this will skip leading and trailing\n-    characters which are identical to keep the diff minimal.\n-\n-    If the input are bytes they will be safely converted to text.\n-    \"\"\"\n-    from difflib import ndiff\n-\n-    explanation = []\n-\n-    def escape_for_readable_diff(binary_text):\n-        \"\"\"\n-        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n-        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n-        newlines and carriage returns (#429).\n-        \"\"\"\n-        r = six.text_type(repr(binary_text)[1:-1])\n-        r = r.replace(r\"\\n\", \"\\n\")\n-        r = r.replace(r\"\\r\", \"\\r\")\n-        return r\n-\n-    if isinstance(left, bytes):\n-        left = escape_for_readable_diff(left)\n-    if isinstance(right, bytes):\n-        right = escape_for_readable_diff(right)\n-    if verbose < 1:\n-        i = 0  # just in case left or right has zero length\n-        for i in range(min(len(left), len(right))):\n-            if left[i] != right[i]:\n-                break\n-        if i > 42:\n-            i -= 10  # Provide some context\n-            explanation = [\n-                u\"Skipping %s identical leading characters in diff, use -v to show\" % i\n-            ]\n-            left = left[i:]\n-            right = right[i:]\n-        if len(left) == len(right):\n-            for i in range(len(left)):\n-                if left[-i] != right[-i]:\n-                    break\n-            if i > 42:\n-                i -= 10  # Provide some context\n-                explanation += [\n-                    u\"Skipping {} identical trailing \"\n-                    u\"characters in diff, use -v to show\".format(i)\n-                ]\n-                left = left[:-i]\n-                right = right[:-i]\n-    keepends = True\n-    if left.isspace() or right.isspace():\n-        left = repr(str(left))\n-        right = repr(str(right))\n-        explanation += [u\"Strings contain only whitespace, escaping them using repr()\"]\n-    explanation += [\n-        line.strip(\"\\n\")\n-        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n-    ]\n-    return explanation\n-\n-\n-def _compare_eq_verbose(left, right):\n-    keepends = True\n-    left_lines = repr(left).splitlines(keepends)\n-    right_lines = repr(right).splitlines(keepends)\n-\n-    explanation = []\n-    explanation += [u\"-\" + line for line in left_lines]\n-    explanation += [u\"+\" + line for line in right_lines]\n-\n-    return explanation\n-\n-\n-def _compare_eq_iterable(left, right, verbose=0):\n-    if not verbose:\n-        return [u\"Use -v to get the full diff\"]\n-    # dynamic import to speedup pytest\n-    import difflib\n-\n-    try:\n-        left_formatting = pprint.pformat(left).splitlines()\n-        right_formatting = pprint.pformat(right).splitlines()\n-        explanation = [u\"Full diff:\"]\n-    except Exception:\n-        # hack: PrettyPrinter.pformat() in python 2 fails when formatting items that can't be sorted(), ie, calling\n-        # sorted() on a list would raise. See issue #718.\n-        # As a workaround, the full diff is generated by using the repr() string of each item of each container.\n-        left_formatting = sorted(repr(x) for x in left)\n-        right_formatting = sorted(repr(x) for x in right)\n-        explanation = [u\"Full diff (fallback to calling repr on each item):\"]\n-    explanation.extend(\n-        line.strip() for line in difflib.ndiff(left_formatting, right_formatting)\n-    )\n-    return explanation\n-\n-\n-def _compare_eq_sequence(left, right, verbose=0):\n-    explanation = []\n-    len_left = len(left)\n-    len_right = len(right)\n-    for i in range(min(len_left, len_right)):\n-        if left[i] != right[i]:\n-            explanation += [u\"At index %s diff: %r != %r\" % (i, left[i], right[i])]\n-            break\n-    len_diff = len_left - len_right\n-\n-    if len_diff:\n-        if len_diff > 0:\n-            dir_with_more = \"Left\"\n-            extra = saferepr(left[len_right])\n-        else:\n-            len_diff = 0 - len_diff\n-            dir_with_more = \"Right\"\n-            extra = saferepr(right[len_left])\n-\n-        if len_diff == 1:\n-            explanation += [u\"%s contains one more item: %s\" % (dir_with_more, extra)]\n-        else:\n-            explanation += [\n-                u\"%s contains %d more items, first extra item: %s\"\n-                % (dir_with_more, len_diff, extra)\n-            ]\n-    return explanation\n-\n-\n-def _compare_eq_set(left, right, verbose=0):\n-    explanation = []\n-    diff_left = left - right\n-    diff_right = right - left\n-    if diff_left:\n-        explanation.append(u\"Extra items in the left set:\")\n-        for item in diff_left:\n-            explanation.append(saferepr(item))\n-    if diff_right:\n-        explanation.append(u\"Extra items in the right set:\")\n-        for item in diff_right:\n-            explanation.append(saferepr(item))\n-    return explanation\n-\n-\n-def _compare_eq_dict(left, right, verbose=0):\n-    explanation = []\n-    set_left = set(left)\n-    set_right = set(right)\n-    common = set_left.intersection(set_right)\n-    same = {k: left[k] for k in common if left[k] == right[k]}\n-    if same and verbose < 2:\n-        explanation += [u\"Omitting %s identical items, use -vv to show\" % len(same)]\n-    elif same:\n-        explanation += [u\"Common items:\"]\n-        explanation += pprint.pformat(same).splitlines()\n-    diff = {k for k in common if left[k] != right[k]}\n-    if diff:\n-        explanation += [u\"Differing items:\"]\n-        for k in diff:\n-            explanation += [saferepr({k: left[k]}) + \" != \" + saferepr({k: right[k]})]\n-    extra_left = set_left - set_right\n-    len_extra_left = len(extra_left)\n-    if len_extra_left:\n-        explanation.append(\n-            u\"Left contains %d more item%s:\"\n-            % (len_extra_left, \"\" if len_extra_left == 1 else \"s\")\n-        )\n-        explanation.extend(\n-            pprint.pformat({k: left[k] for k in extra_left}).splitlines()\n-        )\n-    extra_right = set_right - set_left\n-    len_extra_right = len(extra_right)\n-    if len_extra_right:\n-        explanation.append(\n-            u\"Right contains %d more item%s:\"\n-            % (len_extra_right, \"\" if len_extra_right == 1 else \"s\")\n-        )\n-        explanation.extend(\n-            pprint.pformat({k: right[k] for k in extra_right}).splitlines()\n-        )\n-    return explanation\n-\n-\n-def _compare_eq_cls(left, right, verbose, type_fns):\n-    isdatacls, isattrs = type_fns\n-    if isdatacls(left):\n-        all_fields = left.__dataclass_fields__\n-        fields_to_check = [field for field, info in all_fields.items() if info.compare]\n-    elif isattrs(left):\n-        all_fields = left.__attrs_attrs__\n-        fields_to_check = [field.name for field in all_fields if field.cmp]\n-\n-    same = []\n-    diff = []\n-    for field in fields_to_check:\n-        if getattr(left, field) == getattr(right, field):\n-            same.append(field)\n-        else:\n-            diff.append(field)\n-\n-    explanation = []\n-    if same and verbose < 2:\n-        explanation.append(u\"Omitting %s identical items, use -vv to show\" % len(same))\n-    elif same:\n-        explanation += [u\"Matching attributes:\"]\n-        explanation += pprint.pformat(same).splitlines()\n-    if diff:\n-        explanation += [u\"Differing attributes:\"]\n-        for field in diff:\n-            explanation += [\n-                (u\"%s: %r != %r\") % (field, getattr(left, field), getattr(right, field))\n-            ]\n-    return explanation\n-\n-\n-def _notin_text(term, text, verbose=0):\n-    index = text.find(term)\n-    head = text[:index]\n-    tail = text[index + len(term) :]\n-    correct_text = head + tail\n-    diff = _diff_text(correct_text, text, verbose)\n-    newdiff = [u\"%s is contained here:\" % saferepr(term, maxsize=42)]\n-    for line in diff:\n-        if line.startswith(u\"Skipping\"):\n-            continue\n-        if line.startswith(u\"- \"):\n-            continue\n-        if line.startswith(u\"+ \"):\n-            newdiff.append(u\"  \" + line[2:])\n-        else:\n-            newdiff.append(line)\n-    return newdiff\n+def _pytest_all_helper(iterable):\n+    \"\"\"Helper for rewritten all() assertions\"\"\"\n+    for item in iterable:\n+        if not item:\n+            return False\n+    return True\n+\n+def _pytest_any_helper(iterable): \n+    \"\"\"Helper for rewritten any() assertions\"\"\"\n+    for item in iterable:\n+        if item:\n+            return True\n+    return False\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}