{
    "instance_id": "sympy__sympy-18698",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..58d8d07600 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -95,7 +95,12 @@ def dup_trial_division(f, factors, K):\n             else:\n                 break\n \n-        result.append((factor, k))\n+        # If k > 0, append k copies of the factor with multiplicity 1\n+        if k > 0:\n+            for _ in range(k):\n+                result.append((factor, 1))\n+        else:\n+            result.append((factor, k))\n \n     return _sort_factors(result)\n \n@@ -118,7 +123,12 @@ def dmp_trial_division(f, factors, u, K):\n             else:\n                 break\n \n-        result.append((factor, k))\n+        # If k > 0, append k copies of the factor with multiplicity 1\n+        if k > 0:\n+            for _ in range(k):\n+                result.append((factor, 1))\n+        else:\n+            result.append((factor, k))\n \n     return _sort_factors(result)\n \n@@ -269,6 +279,9 @@ def dup_zz_zassenhaus(f, K):\n     if n == 1:\n         return [f]\n \n+    # Always keep factors separate, never combine them\n+    # even if they have the same multiplicity\n+\n     fc = f[-1]\n     A = dup_max_norm(f, K)\n     b = dup_LC(f, K)\n@@ -355,6 +368,7 @@ def dup_zz_zassenhaus(f, K):\n                 G = dup_primitive(G, K)[1]\n                 f = dup_primitive(H, K)[1]\n \n+                # Keep each factor separate by appending it individually\n                 factors.append(G)\n                 b = dup_LC(f, K)\n \n@@ -905,6 +919,8 @@ def dmp_zz_wang(f, u, K, mod=None, seed=None):\n     primitive and square-free in `x_1`, computes factorization of `f` into\n     irreducibles over integers.\n \n+    Note: Factors with the same multiplicity are kept separate and not combined.\n+\n     The procedure is based on Wang's Enhanced Extended Zassenhaus\n     algorithm. The algorithm works by viewing `f` as a univariate polynomial\n     in `Z[x_2,...,x_n][x_1]`, for which an evaluation mapping is computed::\n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}