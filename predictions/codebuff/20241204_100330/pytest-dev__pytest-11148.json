{
    "instance_id": "pytest-dev__pytest-11148",
    "model_name_or_path": "codebuff",
    "model_patch": "diff --git a/src/_pytest/mark/__init__.py b/src/_pytest/mark/__init__.py\nindex de46b4c8a..3dec471f4 100644\n--- a/src/_pytest/mark/__init__.py\n+++ b/src/_pytest/mark/__init__.py\n@@ -248,9 +248,31 @@ def _parse_expression(expr: str, exc_message: str) -> Expression:\n \n \n def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n+    # When using importlib mode, ensure consistent module imports\n+    if config.getoption(\"import_mode\") == \"importlib\":\n+        _ensure_consistent_module_imports()\n     deselect_by_keyword(items, config)\n     deselect_by_mark(items, config)\n \n+def _ensure_consistent_module_imports() -> None:\n+    \"\"\"Ensure modules are imported consistently when using importlib mode.\n+    \n+    This helps prevent the same module being imported multiple times through\n+    different paths, which can happen with namespace packages.\n+    \"\"\"\n+    import sys\n+    modules = {}\n+    for name, module in list(sys.modules.items()):\n+        if module is not None:\n+            # Get the canonical name for this module\n+            canonical_name = getattr(module, \"__name__\", name)\n+            if canonical_name in modules:\n+                # If we've seen this module before under a different name,\n+                # ensure we use the same instance\n+                sys.modules[name] = modules[canonical_name]\n+            else:\n+                modules[canonical_name] = module\n+\n \n def pytest_configure(config: Config) -> None:\n     config.stash[old_mark_config_key] = MARK_GEN._config\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex bc10d3b90..7854dfe2b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -400,10 +400,15 @@ def normalize_mark_list(\n     :param mark_list: marks to normalize\n     :returns: A new list of the extracted Mark objects\n     \"\"\"\n+    seen_modules = {}  # Track modules we've seen to ensure consistent imports\n     for mark in mark_list:\n         mark_obj = getattr(mark, \"mark\", mark)\n         if not isinstance(mark_obj, Mark):\n             raise TypeError(f\"got {repr(mark_obj)} instead of Mark\")\n+        # If this mark comes from a module, ensure we use a consistent import\n+        module = getattr(mark_obj, \"__module__\", None)\n+        if module and module not in seen_modules:\n+            seen_modules[module] = sys.modules.get(module)\n         yield mark_obj\n \n \n",
    "cost": 0,
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "resolved": false
}